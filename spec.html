<pre class="metadata">
title: Cancelable Promises
status: proposal
stage: 1
location: https://domenic.github.io/cancelable-promise/
copyright: false
contributors: Domenic Denicola
</pre>
<script src="https://bterlson.github.io/ecmarkup/ecmarkup.js" defer></script>
<link rel="stylesheet" href="https://bterlson.github.io/ecmarkup/elements.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/solarized_light.min.css">

<emu-intro>
  <h1>Introduction</h1>

  <p>This is a work-in-progress formalization of the work in <a href="https://github.com/domenic/cancelable-promise">domenic/cancelable-promise</a> and <a href="https://github.com/zenparsing/es-cancel-token">zenparsing/es-cancel-token</a>. Much is left to do:</p>

  <ul>
    <li>Spec `Promise.all` and `Promise.race` behavior</li>
    <li>Spec cancel tokens</li>
    <li>Spec syntax for `throw return` and `catch return`.</li>
  </ul>

  <p>See also the <a href="https://github.com/domenic/cancelable-promise/issues">issues</a>, which contain many ongoing discussions and debates.</p>
</emu-intro>

<emu-clause id="sec-completion-record-specification-type">
  <h1>The Completion Record Specification Type</h1>

  <p>The Completion type is a Record used to explain the runtime propagation of values and control flow such as the behaviour of statements (`break`, `continue`, `return`<del> and `throw`</del><ins>, `throw`, and `throw return`</ins>) that perform nonlocal transfers of control.</p>
  <p>Values of the Completion type are Record values whose fields are defined as by <emu-xref href="#table-8"></emu-xref>. Such values are referred to as <dfn>Completion Record</dfn>s.</p>
  <emu-table id="table-8" caption="Completion Record Fields">
    <table>
      <tbody>
      <tr>
        <th>
          Field
        </th>
        <th>
          Value
        </th>
        <th>
          Meaning
        </th>
      </tr>
      <tr>
        <td>
          [[Type]]
        </td>
        <td>
          One of ~normal~, ~break~, ~continue~, ~return~, <del>or ~throw~</del><ins>~throw~, or ~throw return~</ins>
        </td>
        <td>
          The type of completion that occurred.
        </td>
      </tr>
      <tr>
        <td>
          [[Value]]
        </td>
        <td>
          any ECMAScript language value or ~empty~
        </td>
        <td>
          The value that was produced.
        </td>
      </tr>
      <tr>
        <td>
          [[Target]]
        </td>
        <td>
          any ECMAScript string or ~empty~
        </td>
        <td>
          The target label for directed control transfers.
        </td>
      </tr>
      </tbody>
    </table>
  </emu-table>

  <p>The term &ldquo;<dfn>abrupt completion</dfn>&rdquo; refers to any completion with a [[Type]] value other than ~normal~.</p>

  <emu-clause id="sec-updateempty" aoid="UpdateEmpty">
    <h1>UpdateEmpty ( _completionRecord_, _value_)</h1>
    <p>The abstract operation UpdateEmpty with arguments _completionRecord_ and _value_ performs the following steps:</p>
    <emu-alg>
      1. Assert: If _completionRecord_.[[Type]] is either ~return~<del> or ~throw~</del><ins>, ~throw~, or ~throw return~</ins>, then _completionRecord_.[[Value]] is not ~empty~.
      1. If _completionRecord_.[[Value]] is not ~empty~, return Completion(_completionRecord_).
      1. Return Completion{[[Type]]: _completionRecord_.[[Type]], [[Value]]: _value_, [[Target]]: _completionRecord_.[[Target]] }.
    </emu-alg>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-promise-objects">
  <h1>Promise Objects</h1>
  <p>A Promise is an object that is used as a placeholder for the eventual results of a deferred (and possibly asynchronous) computation.</p>
  <p>Any Promise object is in one of four mutually exclusive states: <em>fulfilled</em>, <em>rejected</em><ins>, <em>canceled</em></ins>, and <em>pending</em>:</p>
  <ul>
    <li>
      A promise `p` is fulfilled if <code>p.then(f, r<ins>, c</ins>)</code> will immediately enqueue a Job to call the function `f`.
    </li>
    <li>
      A promise `p` is rejected if <code>p.then(f, r<ins>, c</ins>)</code> will immediately enqueue a Job to call the function `r`.
    </li>
    <li>
      <ins>A promise `p` is canceled if `p.then(f, r, c)` will immediately enqueue a Job to call the function `c`.</ins>
    </li>
    <li>
      A promise is pending if it is neither fulfilled nor rejected<ins> nor canceled</ins>.
    </li>
  </ul>
  <p>A promise is said to be <em>settled</em> if it is not pending, i.e. if it is either fulfilled or rejected<ins> or canceled</ins>.</p>
  <p>A promise is <em>resolved</em> if it is settled or if it has been &ldquo;locked in&rdquo; to match the state of another promise. Attempting to resolve<del> or reject</del><ins>, reject, or cancel</ins> a resolved promise has no effect. A promise is <em>unresolved</em> if it is not resolved. An unresolved promise is always in the pending state. A resolved promise may be pending, fulfilled<del> or rejected</del><ins>, rejected, or canceled</ins>.</p>

  <emu-clause id="sec-promise-abstract-operations">
    <h1>Promise Abstract Operations</h1>

    <!-- es6num="25.4.1.1" -->
    <emu-clause id="sec-promisecapability-records">
      <h1>PromiseCapability Records</h1>
      <p>A PromiseCapability is a Record value used to encapsulate a promise object along with the functions that are capable of resolving<del> or rejecting</del><ins>, rejecting, or canceling</ins> that promise object. PromiseCapability records are produced by the NewPromiseCapability abstract operation.</p>
      <p>PromiseCapability Records have the fields listed in <emu-xref href="#table-57"></emu-xref>.</p>
      <emu-table id="table-57" caption="PromiseCapability Record Fields">
        <table>
          <tbody>
          <tr>
            <th>
              Field Name
            </th>
            <th>
              Value
            </th>
            <th>
              Meaning
            </th>
          </tr>
          <tr>
            <td>
              [[Promise]]
            </td>
            <td>
              An object
            </td>
            <td>
              An object that is usable as a promise.
            </td>
          </tr>
          <tr>
            <td>
              [[Resolve]]
            </td>
            <td>
              A function object
            </td>
            <td>
              The function that is used to resolve the given promise object.
            </td>
          </tr>
          <tr>
            <td>
              [[Reject]]
            </td>
            <td>
              A function object
            </td>
            <td>
              The function that is used to reject the given promise object.
            </td>
          </tr>
          <tr>
            <td>
              <ins>[[Cancel]]</ins>
            </td>
            <td>
              <ins>A function object</ins>
            </td>
            <td>
              <ins>The function that is used to cancel the given promise object.</ins>
            </td>
          </tr>
          </tbody>
        </table>
      </emu-table>

      <!-- es6num="25.4.1.1.1" -->
      <emu-clause id="sec-ifabruptrejectpromise" aoid="IfAbruptRejectPromise">
        <h1>IfAbruptRejectPromise ( _value_, _capability_ )</h1>
        <p>IfAbruptRejectPromise is a short hand for a sequence of algorithm steps that use a PromiseCapability record. An algorithm step of the form:</p>
        <emu-alg>
          1. IfAbruptRejectPromise(_value_, _capability_).
        </emu-alg>
        <p>means the same thing as:</p>
        <emu-alg>
          1. If _value_ is an abrupt completion, then
            1. Perform ? Call(_capability_.[[Reject]], *undefined*, &laquo; _value_.[[Value]] &raquo;).
            1. Return _capability_.[[Promise]].
          1. Else if _value_ is a Completion Record, let _value_ be _value_.[[Value]].
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <!-- es6num="25.4.1.2" -->
    <emu-clause id="sec-promisereaction-records">
      <h1>PromiseReaction Records</h1>
      <p>The PromiseReaction is a Record value used to store information about how a promise should react when it becomes resolved or rejected with a given value. PromiseReaction records are created by the PerformPromiseThen abstract operation, and are used by a PromiseReactionJob.</p>
      <p>PromiseReaction records have the fields listed in <emu-xref href="#table-58"></emu-xref>.</p>
      <emu-table id="table-58" caption="PromiseReaction Record Fields">
        <table>
          <tbody>
          <tr>
            <th>
              Field Name
            </th>
            <th>
              Value
            </th>
            <th>
              Meaning
            </th>
          </tr>
          <tr>
            <td>
              [[Capabilities]]
            </td>
            <td>
              A PromiseCapability record
            </td>
            <td>
              The capabilities of the promise for which this record provides a reaction handler.
            </td>
          </tr>
          <tr>
            <td>
              [[Type]]
            </td>
            <td>
              Either `"Fulfill"`<del> or `"Reject"`</del><ins>, `"Reject"`, or `"Cancel"`</ins>.
            </td>
            <td>
              The [[Type]] is used when [[Handler]] is *undefined* to allow for behavior specific to the settlement type.
            </td>
          </tr>
          <tr>
            <td>
              [[Handler]]
            </td>
            <td>
              A function object or *undefined*.
            </td>
            <td>
              The function that should be applied to the incoming value, and whose return value will govern what happens to the derived promise. If [[Handler]] is *undefined*, a function that depends on the value of [[Type]] will be used instead.
            </td>
          </tr>
          </tbody>
        </table>
      </emu-table>
    </emu-clause>

    <!-- es6num="25.4.1.3" -->
    <emu-clause id="sec-createresolvingfunctions" aoid="CreateResolvingFunctions">
      <h1>CreateResolvingFunctions ( _promise_ )</h1>
      <p>When CreateResolvingFunctions is performed with argument _promise_, the following steps are taken:</p>
      <emu-alg>
        1. Let _alreadyResolved_ be a new Record { [[Value]]: *false* }.
        1. Let _resolve_ be a new built-in function object as defined in Promise Resolve Functions (<emu-xref href="#sec-promise-resolve-functions"></emu-xref>).
        1. Set _resolve_.[[Promise]] to _promise_.
        1. Set _resolve_.[[AlreadyResolved]] to _alreadyResolved_.
        1. Let _reject_ be a new built-in function object as defined in Promise Reject Functions (<emu-xref href="#sec-promise-reject-functions"></emu-xref>).
        1. Set _reject_.[[Promise]] to _promise_.
        1. Set _reject_.[[AlreadyResolved]] to _alreadyResolved_.
        1. <ins>Let _cancel_ be a new built-in function object as defined in Promise Cancel Functions (<emu-xref href="#sec-promise-cancel-functions"></emu-xref>).</ins>
        1. <ins>Set _cancel_.[[Promise]] to _promise_.</ins>
        1. <ins>Set _cancel_.[[AlreadyResolved]] to _alreadyResolved_.</ins>
        1. Return a new Record { [[Resolve]]: _resolve_, [[Reject]]: _reject_<ins>, [[Cancel]]: _cancel_</ins> }.
      </emu-alg>

      <emu-clause id="sec-promise-cancel-functions">
        <h1><ins>Promise Cancel Functions</ins></h1>
        <p>A promise cancel function is an anonymous built-in function that has [[Promise]] and [[AlreadyResolved]] internal slots.</p>
        <p>When a promise cancel function _F_ is called with argument _reason_, the following steps are taken:</p>
        <emu-alg>
          1. Assert: _F_ has a [[Promise]] internal slot whose value is an Object.
          1. Let _promise_ be the value of _F_.[[Promise]].
          1. Let _alreadyResolved_ be the value of _F_.[[AlreadyResolved]].
          1. If _alreadyResolved_.[[Value]] is *true*, return *undefined*.
          1. Set _alreadyResolved_.[[Value]] to *true*.
          1. Return CancelPromise(_promise_, _reason_).
        </emu-alg>
        <p>The `length` property of a promise cancel function is 1.</p>
      </emu-clause>

      <!-- es6num="25.4.1.3.1" -->
      <emu-clause id="sec-promise-reject-functions">
        <h1>Promise Reject Functions</h1>
        <p>A promise reject function is an anonymous built-in function that has [[Promise]] and [[AlreadyResolved]] internal slots.</p>
        <p>When a promise reject function _F_ is called with argument _reason_, the following steps are taken:</p>
        <emu-alg>
          1. Assert: _F_ has a [[Promise]] internal slot whose value is an Object.
          1. Let _promise_ be the value of _F_.[[Promise]].
          1. Let _alreadyResolved_ be the value of _F_.[[AlreadyResolved]].
          1. If _alreadyResolved_.[[Value]] is *true*, return *undefined*.
          1. Set _alreadyResolved_.[[Value]] to *true*.
          1. Return RejectPromise(_promise_, _reason_).
        </emu-alg>
        <p>The `length` property of a promise reject function is 1.</p>
      </emu-clause>

      <!-- es6num="25.4.1.3.2" -->
      <emu-clause id="sec-promise-resolve-functions">
        <h1>Promise Resolve Functions</h1>
        <p>A promise resolve function is an anonymous built-in function that has [[Promise]] and [[AlreadyResolved]] internal slots.</p>
        <p>When a promise resolve function _F_ is called with argument _resolution_, the following steps are taken:</p>
        <emu-alg>
          1. Assert: _F_ has a [[Promise]] internal slot whose value is an Object.
          1. Let _promise_ be the value of _F_.[[Promise]].
          1. Let _alreadyResolved_ be the value of _F_.[[AlreadyResolved]].
          1. If _alreadyResolved_.[[Value]] is *true*, return *undefined*.
          1. Set _alreadyResolved_.[[Value]] to *true*.
          1. If SameValue(_resolution_, _promise_) is *true*, then
            1. Let _selfResolutionError_ be a newly created *TypeError* object.
            1. Return RejectPromise(_promise_, _selfResolutionError_).
          1. If Type(_resolution_) is not Object, then
            1. Return FulfillPromise(_promise_, _resolution_).
          1. Let _then_ be Get(_resolution_, `"then"`).
          1. <del>If _then_ is an abrupt completion, then</del>
            1. <del>Return RejectPromise(_promise_, _then_.[[Value]]).</del>
          1. <ins>If _then_.[[Type]] is ~throw return~,
            1. <ins>Return CancelPromise(_promise_, _then_.[[Value]]).</ins>
          1. <ins>If _then_.[[Type]] is ~throw~,
            1. <ins>Return RejectPromise(_promise_, _then_.[[Value]]).</ins>
          1. <ins>Assert: _then_.[[Type]] is ~normal~.</ins>
          1. Let _thenAction_ be _then_.[[Value]].
          1. If IsCallable(_thenAction_) is *false*, then
            1. Return FulfillPromise(_promise_, _resolution_).
          1. Perform EnqueueJob(`"PromiseJobs"`, PromiseResolveThenableJob, &laquo; _promise_, _resolution_, _thenAction_ &raquo;).
          1. Return *undefined*.
        </emu-alg>
        <p>The `length` property of a promise resolve function is 1.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-cancelpromise" aoid="CancelPromise">
      <h1><ins>CancelPromise ( _promise_, _cancelation_ )</ins></h1>
      <p>When the CancelPromise abstract operation is called with arguments _promise_ and _cancelation_, the following steps are taken:</p>
      <emu-alg>
        1. Assert: The value of _promise_.[[PromiseState]] is `"pending"`.
        1. Let _reactions_ be the value of _promise_.[[PromiseCancelReactions]].
        1. Set the value of _promise_.[[PromiseResult]] to _value_.
        1. Set the value of _promise_.[[PromiseFulfillReactions]] to *undefined*.
        1. Set the value of _promise_.[[PromiseRejectReactions]] to *undefined*.
        1. Set the value of _promise_.[[PromiseCancelReactions]] to *undefined*.
        1. Set the value of _promise_.[[PromiseState]] to `"canceled"`.
        1. Return TriggerPromiseReactions(_reactions_, _cancelation_).
      </emu-alg>
    </emu-clause>

    <!-- es6num="25.4.1.4" -->
    <emu-clause id="sec-fulfillpromise" aoid="FulfillPromise">
      <h1>FulfillPromise ( _promise_, _value_ )</h1>
      <p>When the FulfillPromise abstract operation is called with arguments _promise_ and _value_, the following steps are taken:</p>
      <emu-alg>
        1. Assert: The value of _promise_.[[PromiseState]] is `"pending"`.
        1. Let _reactions_ be the value of _promise_.[[PromiseFulfillReactions]].
        1. Set the value of _promise_.[[PromiseResult]] to _value_.
        1. Set the value of _promise_.[[PromiseFulfillReactions]] to *undefined*.
        1. Set the value of _promise_.[[PromiseRejectReactions]] to *undefined*.
        1. <ins>Set the value of _promise_.[[PromiseCancelReactions]] to *undefined*.</ins>
        1. Set the value of _promise_.[[PromiseState]] to `"fulfilled"`.
        1. Return TriggerPromiseReactions(_reactions_, _value_).
      </emu-alg>
    </emu-clause>

    <!-- es6num="25.4.1.5" -->
    <emu-clause id="sec-newpromisecapability" aoid="NewPromiseCapability">
      <h1>NewPromiseCapability ( _C_ )</h1>
      <p>The abstract operation NewPromiseCapability takes a constructor function, and attempts to use that constructor function in the fashion of the built-in `Promise` constructor to create a Promise object and extract its resolve<del> and reject</del><ins>, reject, and cancel</ins> functions. The promise plus the resolve<del> and reject</del><ins>, reject, and cancel</ins> functions are used to initialize a new PromiseCapability record which is returned as the value of this abstract operation.</p>
      <emu-alg>
        1. If IsConstructor(_C_) is *false*, throw a *TypeError* exception.
        1. NOTE _C_ is assumed to be a constructor function that supports the parameter conventions of the `Promise` constructor (see <emu-xref href="#sec-promise-executor"></emu-xref>).
        1. Let _promiseCapability_ be a new PromiseCapability { [[Promise]]: *undefined*, [[Resolve]]: *undefined*, [[Reject]]: *undefined*<ins>, [[Cancel]]: *undefined*</ins> }.
        1. Let _executor_ be a new built-in function object as defined in GetCapabilitiesExecutor Functions (<emu-xref href="#sec-getcapabilitiesexecutor-functions"></emu-xref>).
        1. Set _executor_.[[Capability]] to _promiseCapability_.
        1. Let _promise_ be ? Construct(_C_, &laquo; _executor_ &raquo;).
        1. If IsCallable(_promiseCapability_.[[Resolve]]) is *false*, throw a *TypeError* exception.
        1. If IsCallable(_promiseCapability_.[[Reject]]) is *false*, throw a *TypeError* exception.
        1. <ins>If IsCallable(_promiseCapability_.[[Cancel]]) is *false*, throw a *TypeError* exception.</ins>
        1. Set _promiseCapability_.[[Promise]] to _promise_.
        1. Return _promiseCapability_.
      </emu-alg>
      <emu-note>
        <p>This abstract operation supports Promise subclassing, as it is generic on any constructor that calls a passed executor function argument in the same way as the Promise constructor. It is used to generalize static methods of the Promise constructor to any subclass.</p>
      </emu-note>

      <!-- es6num="25.4.1.5.1" -->
      <emu-clause id="sec-getcapabilitiesexecutor-functions">
        <h1>GetCapabilitiesExecutor Functions</h1>
        <p>A GetCapabilitiesExecutor function is an anonymous built-in function that has a [[Capability]] internal slot.</p>
        <p>When a GetCapabilitiesExecutor function _F_ is called with arguments _resolve_<del> and _reject_</del><ins>, _reject_, and _cancel_</ins>, the following steps are taken:</p>
        <emu-alg>
          1. Assert: _F_ has a [[Capability]] internal slot whose value is a PromiseCapability Record.
          1. Let _promiseCapability_ be the value of _F_.[[Capability]].
          1. If _promiseCapability_.[[Resolve]] is not *undefined*, throw a *TypeError* exception.
          1. If _promiseCapability_.[[Reject]] is not *undefined*, throw a *TypeError* exception.
          1. <ins>If _promiseCapability_.[[Cancel]] is not *undefined*, throw a *TypeError* exception.</ins>
          1. Set _promiseCapability_.[[Resolve]] to _resolve_.
          1. Set _promiseCapability_.[[Reject]] to _reject_.
          1. <ins>Set _promiseCapability_.[[Cancel]] to _cancel_.</ins>
          1. Return *undefined*.
        </emu-alg>
        <p>The `length` property of a GetCapabilitiesExecutor function is <del>2</del><ins>3</ins>.</p>
      </emu-clause>
    </emu-clause>

    <!-- es6num="25.4.1.6" -->
    <emu-clause id="sec-ispromise" aoid="IsPromise">
      <h1>IsPromise ( _x_ )</h1>
      <p>The abstract operation IsPromise checks for the promise brand on an object.</p>
      <emu-alg>
        1. If Type(_x_) is not Object, return *false*.
        1. If _x_ does not have a [[PromiseState]] internal slot, return *false*.
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <!-- es6num="25.4.1.7" -->
    <emu-clause id="sec-rejectpromise" aoid="RejectPromise">
      <h1>RejectPromise ( _promise_, _reason_ )</h1>
      <p>When the RejectPromise abstract operation is called with arguments _promise_ and _reason_, the following steps are taken:</p>
      <emu-alg>
        1. Assert: The value of _promise_.[[PromiseState]] is `"pending"`.
        1. Let _reactions_ be the value of _promise_.[[PromiseRejectReactions]].
        1. Set the value of _promise_.[[PromiseResult]] to _reason_.
        1. Set the value of _promise_.[[PromiseFulfillReactions]] to *undefined*.
        1. Set the value of _promise_.[[PromiseRejectReactions]] to *undefined*.
        1. <ins>Set the value of _promise_.[[PromiseCancelReactions]] to *undefined*.</ins>
        1. Set the value of _promise_.[[PromiseState]] to `"rejected"`.
        1. If the value of _promise_.[[PromiseIsHandled]] is *false*, perform HostPromiseRejectionTracker(_promise_, `"reject"`).
        1. Return TriggerPromiseReactions(_reactions_, _reason_).
      </emu-alg>
    </emu-clause>

    <!-- es6num="25.4.1.8" -->
    <emu-clause id="sec-triggerpromisereactions" aoid="TriggerPromiseReactions">
      <h1>TriggerPromiseReactions ( _reactions_, _argument_ )</h1>
      <p>The abstract operation TriggerPromiseReactions takes a collection of PromiseReactionRecords and enqueues a new Job for each record. Each such Job processes the [[Type]] and [[Handler]] of the PromiseReactionRecord, and if the [[Handler]] is a function, calls it passing the given argument. If the [[Handler]] is *undefined*, the behavior is determined by the [[Type]].</p>
      <emu-alg>
        1. Repeat for each _reaction_ in _reactions_, in original insertion order
          1. Perform EnqueueJob(`"PromiseJobs"`, PromiseReactionJob, &laquo; _reaction_, _argument_ &raquo;).
        1. Return *undefined*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-host-promise-rejection-tracker" aoid="HostPromiseRejectionTracker">
      <h1>HostPromiseRejectionTracker ( _promise_, _operation_ )</h1>

      <p>HostPromiseRejectionTracker is an implementation-defined abstract operation that allows host environments to track promise rejections.</p>

      <p>An implementation of HostPromiseRejectionTracker must complete normally in all cases. The default implementation of HostPromiseRejectionTracker is to unconditionally return an empty normal completion.</p>

      <emu-note>
        <p>HostPromiseRejectionTracker is called in two scenarios:</p>

        <ul>
          <li>When a promise is rejected without any handlers, it is called with its _operation_ argument set to `"reject"`.</li>
          <li>When a handler is added to a rejected promise for the first time, it is called with its _operation_ argument set to `"handle"`.</li>
        </ul>

        <p>A typical implementation of HostPromiseRejectionTracker might try to notify developers of unhandled rejections, while also being careful to notify them if such previous notifications are later invalidated by new handlers being attached.</p>
      </emu-note>

      <emu-note>
        <p>If _operation_ is `"handle"`, an implementation should not hold a reference to promise in a way that would interfere with garbage collection. An implementation may hold a reference to promise if operation is `"reject"`, since it is expected that rejections will be rare and not on hot code paths.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <!-- es6num="25.4.2" -->
  <emu-clause id="sec-promise-jobs">
    <h1>Promise Jobs</h1>

    <!-- es6num="25.4.2.1" -->
    <emu-clause id="sec-promisereactionjob" aoid="PromiseReactionJob">
      <h1>PromiseReactionJob ( _reaction_, _argument_ )</h1>
      <p>The job PromiseReactionJob with parameters _reaction_ and _argument_ applies the appropriate handler to the incoming value, and uses the handler's return value to resolve or reject the derived promise associated with that handler.</p>
      <emu-alg>
        1. Assert: _reaction_ is a PromiseReaction Record.
        1. Let _promiseCapability_ be _reaction_.[[Capabilities]].
        1. Let _type_ be _reaction_.[[Type]].
        1. Let _handler_ be _reaction_.[[Handler]].
        1. If _handler_ is *undefined*, then
          1. If _type_ is `"Fulfill"`, let _handlerResult_ be NormalCompletion(_argument_).
          1. <del>Otherwise, _type_ is `"Reject"`. Let</del><ins>If _type_ is `"Reject"`, let</ins> _handlerResult_ be Completion { [[Type]]: ~throw~, [[Value]]: _argument_, [[Target]]: ~empty~ }.
          1. <ins>Otherwise, _type_ is `"Cancel"`. Let _handlerResult_ be Completion { [[Type]]: ~throw return~, [[Value]]: _argument_, [[Target]]: ~empty~ }.</ins>
        1. Else, let _handlerResult_ be Call(_handler_, *undefined*, &laquo; _argument_ &raquo;).
        1. <del>If _handlerResult_ is an abrupt completion, then</del>
          1. <del>Let _status_ be Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; _handlerResult_.[[Value]] &raquo;).</del>
        1. <del>Else,</del>
          1. <del>Let _status_ be Call(_promiseCapability_.[[Resolve]], *undefined*, &laquo; _handlerResult_.[[Value]] &raquo;).</del>
        1. <ins>If _handlerResult_.[[Type]] is ~normal~, then</ins>
          1. <ins>Let _status_ be Call(_promiseCapability_.[[Resolve]], *undefined*, &laquo; _handlerResult_.[[Value]] &raquo;).</ins>
        1. <ins>If _handlerResult_.[[Type]] is ~throw~, then</ins>
          1. <ins>Let _status_ be Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; _handlerResult_.[[Value]] &raquo;).</ins>
        1. <ins>Otherwise, _handlerResult_.[[Type]] is ~throw return~. Then:</ins>
          1. <ins>Let _status_ be Call(_promiseCapability_.[[Cancel]], *undefined*, &laquo; _handlerResult_.[[Value]] &raquo;).</ins>
        1. Return Completion(_status_).
      </emu-alg>
    </emu-clause>

    <!-- es6num="25.4.2.2" -->
    <emu-clause id="sec-promiseresolvethenablejob" aoid="PromiseResolveThenableJob">
      <h1>PromiseResolveThenableJob ( _promiseToResolve_, _thenable_, _then_)</h1>
      <p>The job PromiseResolveThenableJob with parameters _promiseToResolve_, _thenable_, and _then_ performs the following steps:</p>
      <emu-alg>
        1. Let _resolvingFunctions_ be CreateResolvingFunctions(_promiseToResolve_).
        1. Let _thenCallResult_ be Call(_then_, _thenable_, &laquo; _resolvingFunctions_.[[Resolve]], _resolvingFunctions_.[[Reject]]<ins>, _resolvingFunctions_.[[Cancel]]</ins> &raquo;).
        1. <del>If _thenCallResult_ is an abrupt completion, then</del>
        1. <ins>If _thenCallResult_.[[Type]] is ~throw~, then</ins>
          1. Let _status_ be Call(_resolvingFunctions_.[[Reject]], *undefined*, &laquo; _thenCallResult_.[[Value]] &raquo;).
          1. Return Completion(_status_).
        1. <ins>If _thenCallResult_.[[Type]] is ~throw return~, then</ins>
          1. <ins>Let _status_ be Call(_resolvingFunctions_.[[Cancel]], *undefined*, &laquo; _thenCallResult_.[[Value]] &raquo;).</ins>
          1. <ins>Return Completion(_status_).</ins>
        1. <ins>Assert: _thenCallResult_.[[Type]] is ~normal~.</ins>
        1. Return Completion(_thenCallResult_).
      </emu-alg>
      <emu-note>
        <p>This Job uses the supplied thenable and its `then` method to resolve the given promise. This process must take place as a Job to ensure that the evaluation of the `then` method occurs after evaluation of any surrounding code has completed.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <!-- es6num="25.4.3" -->
  <emu-clause id="sec-promise-constructor">
    <h1>The Promise Constructor</h1>
    <p>The Promise constructor is the <dfn>%Promise%</dfn> intrinsic object and the initial value of the `Promise` property of the global object. When called as a constructor it creates and initializes a new Promise object. `Promise` is not intended to be called as a function and will throw an exception when called in that manner.</p>
    <p>The `Promise` constructor is designed to be subclassable. It may be used as the value in an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified `Promise` behaviour must include a `super` call to the `Promise` constructor to create and initialize the subclass instance with the internal state necessary to support the `Promise` and `Promise.prototype` built-in methods.</p>

    <!-- es6num="25.4.3.1" -->
    <emu-clause id="sec-promise-executor">
      <h1>Promise ( _executor_ )</h1>
      <p>When the `Promise` function is called with argument _executor_, the following steps are taken:</p>
      <emu-alg>
        1. If NewTarget is *undefined*, throw a *TypeError* exception.
        1. If IsCallable(_executor_) is *false*, throw a *TypeError* exception.
        1. Let _promise_ be ? OrdinaryCreateFromConstructor(NewTarget, `"%PromisePrototype%"`, &laquo; [[PromiseState]], [[PromiseResult]], [[PromiseFulfillReactions]], [[PromiseRejectReactions]], [[PromiseCancelReactions]], [[PromiseIsHandled]] &raquo;).
        1. Set _promise_.[[PromiseState]] to `"pending"`.
        1. Set _promise_.[[PromiseFulfillReactions]] to a new empty List.
        1. Set _promise_.[[PromiseRejectReactions]] to a new empty List.
        1. <ins>Set _promise_.[[PromiseCancelReactions]] to a new empty List.</ins>
        1. Set _promise_.[[PromiseIsHandled]] to *false*.
        1. Let _resolvingFunctions_ be CreateResolvingFunctions(_promise_).
        1. Let _completion_ be Call(_executor_, *undefined*, &laquo; _resolvingFunctions_.[[Resolve]], _resolvingFunctions_.[[Reject]], <ins>_resolvingFunctions.[[Cancel]]</ins> &raquo;).
        1. <del>If _completion_ is an abrupt completion, then</del>
        1. <ins>If _completion_.[[Type]] is ~throw~, then</ins>
          1. Perform ? Call(_resolvingFunctions_.[[Reject]], *undefined*, &laquo; _completion_.[[Value]] &raquo;).
        1. <ins>If _completion_.[[Type]] is ~throw return~, then</ins>
          1. <ins>Perform ? Call(_resolvingFunctions_.[[Cancel]], *undefined*, &laquo; _completion_.[[Value]] &raquo;).</ins>
        1. Return _promise_.
      </emu-alg>
      <emu-note>
        <p>The _executor_ argument must be a function object. It is called for initiating and reporting completion of the possibly deferred action represented by this Promise object. The executor is called with <del>two</del><ins>three</ins> arguments: _resolve_<del> and _reject_</del><ins>, _reject_, and _cancel_</ins>. These are functions that may be used by the _executor_ function to report eventual completion<del> or failure</del><ins>, failure, or cancelation</ins> of the deferred computation. Returning from the executor function does not mean that the deferred action has been completed but only that the request to eventually perform the deferred action has been accepted.</p>
        <p>The _resolve_ function that is passed to an _executor_ function accepts a single argument. The _executor_ code may eventually call the _resolve_ function to indicate that it wishes to resolve the associated Promise object. The argument passed to the _resolve_ function represents the eventual value of the deferred action and can be either the actual fulfillment value or another Promise object which will provide the value if it is fulfilled.</p>
        <p>The _reject_ function that is passed to an _executor_ function accepts a single argument. The _executor_ code may eventually call the _reject_ function to indicate that the associated Promise is rejected and will never be fulfilled. The argument passed to the _reject_ function is used as the rejection value of the promise. Typically it will be an `Error` object.</p>
        <p><ins>The _cancel_ function that is passed to an _executor_ function accepts a single argument. The _executor_ code may eventually call the _cancel_ function to indicate that the associated Promise is canceled and will never be fulfilled or rejected. The argument passed to the _cancel_ function is used as the cancelation of the promise.</p>
        <p>The <del>resolve and reject</del><ins>_resolve_, _reject_, and _cancel_</ins> functions passed to an _executor_ function by the Promise constructor have the capability to actually resolve<del> and reject</del><ins>, reject, and cancel</ins> the associated promise. Subclasses may have different constructor behaviour that passes in customized values for <del>resolve and reject</del><ins>_resolve_, _reject_, and _cancel_</ins>.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <!-- es6num="25.4.4" -->
  <emu-clause id="sec-properties-of-the-promise-constructor">
    <h1>Properties of the Promise Constructor</h1>
    <p>The value of the [[Prototype]] internal slot of the `Promise` constructor is the intrinsic object %FunctionPrototype%.</p>
    <p>The Promise constructor has the following properties:</p>

    <!-- es6num="25.4.4.1" -->
    <emu-clause id="sec-promise.all">
      <h1>Promise.all ( _iterable_ )</h1>
      <p><ins>TODO update for cancelation</ins></p>
      <p>The `all` function returns a new promise which is fulfilled with an array of fulfillment values for the passed promises, or rejects with the reason of the first passed promise that rejects. It resolves all elements of the passed iterable to promises as it runs this algorithm.</p>
      <emu-alg>
        1. Let _C_ be the *this* value.
        1. If Type(_C_) is not Object, throw a *TypeError* exception.
        1. Let _promiseCapability_ be ? NewPromiseCapability(_C_).
        1. Let _iterator_ be GetIterator(_iterable_).
        1. IfAbruptRejectPromise(_iterator_, _promiseCapability_).
        1. Let _iteratorRecord_ be Record {[[Iterator]]: _iterator_, [[Done]]: *false*}.
        1. Let _result_ be PerformPromiseAll(_iteratorRecord_, _C_, _promiseCapability_).
        1. If _result_ is an abrupt completion, then
          1. If _iteratorRecord_.[[Done]] is *false*, let _result_ be IteratorClose(_iterator_, _result_).
          1. IfAbruptRejectPromise(_result_, _promiseCapability_).
        1. Return Completion(_result_).
      </emu-alg>
      <emu-note>
        <p>The `all` function requires its *this* value to be a constructor function that supports the parameter conventions of the `Promise` constructor.</p>
      </emu-note>

      <!-- es6num="25.4.4.1.1" -->
      <emu-clause id="sec-performpromiseall" aoid="PerformPromiseAll">
        <h1>Runtime Semantics: PerformPromiseAll( _iteratorRecord_, _constructor_, _resultCapability_)</h1>
        <p>When the PerformPromiseAll abstract operation is called with arguments _iteratorRecord_, _constructor_, and _resultCapability_, the following steps are taken:</p>
        <emu-alg>
          1. Assert: _constructor_ is a constructor function.
          1. Assert: _resultCapability_ is a PromiseCapability record.
          1. Let _values_ be a new empty List.
          1. Let _remainingElementsCount_ be a new Record { [[Value]]: 1 }.
          1. Let _index_ be 0.
          1. Repeat
            1. Let _next_ be IteratorStep(_iteratorRecord_.[[Iterator]]).
            1. If _next_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.
            1. ReturnIfAbrupt(_next_).
            1. If _next_ is *false*, then
              1. Set _iteratorRecord_.[[Done]] to *true*.
              1. Set _remainingElementsCount_.[[Value]] to _remainingElementsCount_.[[Value]] - 1.
              1. If _remainingElementsCount_.[[Value]] is 0, then
                1. Let _valuesArray_ be CreateArrayFromList(_values_).
                1. Perform ? Call(_resultCapability_.[[Resolve]], *undefined*, &laquo; _valuesArray_ &raquo;).
              1. Return _resultCapability_.[[Promise]].
            1. Let _nextValue_ be IteratorValue(_next_).
            1. If _nextValue_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.
            1. ReturnIfAbrupt(_nextValue_).
            1. Append *undefined* to _values_.
            1. Let _nextPromise_ be ? Invoke(_constructor_, `"resolve"`, &laquo; _nextValue_ &raquo;).
            1. Let _resolveElement_ be a new built-in function object as defined in Promise.all Resolve Element Functions.
            1. Set _resolveElement_.[[AlreadyCalled]] to a new Record {[[Value]]: *false* }.
            1. Set _resolveElement_.[[Index]] to _index_.
            1. Set _resolveElement_.[[Values]] to _values_.
            1. Set _resolveElement_.[[Capabilities]] to _resultCapability_.
            1. Set _resolveElement_.[[RemainingElements]] to _remainingElementsCount_.
            1. Set _remainingElementsCount_.[[Value]] to _remainingElementsCount_.[[Value]] + 1.
            1. Perform ? Invoke(_nextPromise_, `"then"`, &laquo; _resolveElement_, _resultCapability_.[[Reject]] &raquo;).
            1. Set _index_ to _index_ + 1.
        </emu-alg>
      </emu-clause>

      <!-- es6num="25.4.4.1.2" -->
      <emu-clause id="sec-promise.all-resolve-element-functions">
        <h1>Promise.all Resolve Element Functions</h1>
        <p>A Promise.all resolve element function is an anonymous built-in function that is used to resolve a specific Promise.all element. Each Promise.all resolve element function has [[Index]], [[Values]], [[Capabilities]], [[RemainingElements]], and [[AlreadyCalled]] internal slots.</p>
        <p>When a Promise.all resolve element function _F_ is called with argument _x_, the following steps are taken:</p>
        <emu-alg>
          1. Let _alreadyCalled_ be the value of _F_.[[AlreadyCalled]].
          1. If _alreadyCalled_.[[Value]] is *true*, return *undefined*.
          1. Set _alreadyCalled_.[[Value]] to *true*.
          1. Let _index_ be the value of _F_.[[Index]].
          1. Let _values_ be the value of _F_.[[Values]].
          1. Let _promiseCapability_ be the value of _F_.[[Capabilities]].
          1. Let _remainingElementsCount_ be the value of _F_.[[RemainingElements]].
          1. Set _values_[_index_] to _x_.
          1. Set _remainingElementsCount_.[[Value]] to _remainingElementsCount_.[[Value]] - 1.
          1. If _remainingElementsCount_.[[Value]] is 0, then
            1. Let _valuesArray_ be CreateArrayFromList(_values_).
            1. Return ? Call(_promiseCapability_.[[Resolve]], *undefined*, &laquo; _valuesArray_ &raquo;).
          1. Return *undefined*.
        </emu-alg>
        <p>The `length` property of a Promise.all resolve element function is 1.</p>
      </emu-clause>
    </emu-clause>

    <!-- es6num="25.4.4.2" -->
    <emu-clause id="sec-promise.prototype">
      <h1>Promise.prototype</h1>
      <p>The initial value of `Promise.prototype` is the intrinsic object %PromisePrototype%.</p>
      <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
    </emu-clause>

    <!-- es6num="25.4.4.3" -->
    <emu-clause id="sec-promise.race">
      <h1>Promise.race ( _iterable_ )</h1>
      <p><ins>TODO update for cancelation</ins></p>
      <p>The `race` function returns a new promise which is settled in the same way as the first passed promise to settle. It resolves all elements of the passed _iterable_ to promises as it runs this algorithm.</p>
      <emu-alg>
        1. Let _C_ be the *this* value.
        1. If Type(_C_) is not Object, throw a *TypeError* exception.
        1. Let _promiseCapability_ be ? NewPromiseCapability(_C_).
        1. Let _iterator_ be GetIterator(_iterable_).
        1. IfAbruptRejectPromise(_iterator_, _promiseCapability_).
        1. Let _iteratorRecord_ be Record {[[Iterator]]: _iterator_, [[Done]]: *false*}.
        1. Let _result_ be PerformPromiseRace(_iteratorRecord_, _promiseCapability_, _C_).
        1. If _result_ is an abrupt completion, then
          1. If _iteratorRecord_.[[Done]] is *false*, let _result_ be IteratorClose(_iterator_, _result_).
          1. IfAbruptRejectPromise(_result_, _promiseCapability_).
        1. Return Completion(_result_).
      </emu-alg>
      <emu-note>
        <p>If the _iterable_ argument is empty or if none of the promises in _iterable_ ever settle then the pending promise returned by this method will never be settled.</p>
      </emu-note>
      <emu-note>
        <p>The `race` function expects its *this* value to be a constructor function that supports the parameter conventions of the `Promise` constructor. It also expects that its *this* value provides a `resolve` method.</p>
      </emu-note>

      <!-- es6num="25.4.4.3.1" -->
      <emu-clause id="sec-performpromiserace" aoid="PerformPromiseRace">
        <h1>Runtime Semantics: PerformPromiseRace ( _iteratorRecord_, _promiseCapability_, _C_ )</h1>
        <p>When the PerformPromiseRace abstract operation is called with arguments _iteratorRecord_, _promiseCapability_, and _C_, the following steps are taken:</p>
        <emu-alg>
          1. Repeat
            1. Let _next_ be IteratorStep(_iteratorRecord_.[[Iterator]]).
            1. If _next_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.
            1. ReturnIfAbrupt(_next_).
            1. If _next_ is *false*, then
              1. Set _iteratorRecord_.[[Done]] to *true*.
              1. Return _promiseCapability_.[[Promise]].
            1. Let _nextValue_ be IteratorValue(_next_).
            1. If _nextValue_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.
            1. ReturnIfAbrupt(_nextValue_).
            1. Let _nextPromise_ be ? Invoke(_C_, `"resolve"`, &laquo; _nextValue_ &raquo;).
            1. Perform ? Invoke(_nextPromise_, `"then"`, &laquo; _promiseCapability_.[[Resolve]], _promiseCapability_.[[Reject]] &raquo;).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-promise.reject">
      <h1><ins>Promise.cancel ( _c_ )</ins></h1>
      <p>The `cancel` function returns a new promise canceled with the passed argument.</p>
      <emu-alg>
        1. Let _C_ be the *this* value.
        1. If Type(_C_) is not Object, throw a *TypeError* exception.
        1. Let _promiseCapability_ be ? NewPromiseCapability(_C_).
        1. Perform ? Call(_promiseCapability_.[[Cancel]], *undefined*, &laquo; _r_ &raquo;).
        1. Return _promiseCapability_.[[Promise]].
      </emu-alg>
      <emu-note>
        <p>The `cancel` function expects its *this* value to be a constructor function that supports the parameter conventions of the `Promise` constructor.</p>
      </emu-note>
    </emu-clause>

    <!-- es6num="25.4.4.4" -->
    <emu-clause id="sec-promise.reject">
      <h1>Promise.reject ( _r_ )</h1>
      <p>The `reject` function returns a new promise rejected with the passed argument.</p>
      <emu-alg>
        1. Let _C_ be the *this* value.
        1. If Type(_C_) is not Object, throw a *TypeError* exception.
        1. Let _promiseCapability_ be ? NewPromiseCapability(_C_).
        1. Perform ? Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; _r_ &raquo;).
        1. Return _promiseCapability_.[[Promise]].
      </emu-alg>
      <emu-note>
        <p>The `reject` function expects its *this* value to be a constructor function that supports the parameter conventions of the `Promise` constructor.</p>
      </emu-note>
    </emu-clause>

    <!-- es6num="25.4.4.5" -->
    <emu-clause id="sec-promise.resolve">
      <h1>Promise.resolve ( _x_ )</h1>
      <p>The `resolve` function returns either a new promise resolved with the passed argument, or the argument itself if the argument is a promise produced by this constructor.</p>
      <emu-alg>
        1. Let _C_ be the *this* value.
        1. If Type(_C_) is not Object, throw a *TypeError* exception.
        1. If IsPromise(_x_) is *true*, then
          1. Let _xConstructor_ be ? Get(_x_, `"constructor"`).
          1. If SameValue(_xConstructor_, _C_) is *true*, return _x_.
        1. Let _promiseCapability_ be ? NewPromiseCapability(_C_).
        1. Perform ? Call(_promiseCapability_.[[Resolve]], *undefined*, &laquo; _x_ &raquo;).
        1. Return _promiseCapability_.[[Promise]].
      </emu-alg>
      <emu-note>
        <p>The `resolve` function expects its *this* value to be a constructor function that supports the parameter conventions of the `Promise` constructor.</p>
      </emu-note>
    </emu-clause>

    <!-- es6num="25.4.4.6" -->
    <emu-clause id="sec-get-promise-@@species">
      <h1>get Promise [ @@species ]</h1>
      <p>`Promise[@@species]` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
      <emu-alg>
        1. Return the *this* value.
      </emu-alg>
      <p>The value of the `name` property of this function is `"get [Symbol.species]"`.</p>
      <emu-note>
        <p>Promise prototype methods normally use their `this` object's constructor to create a derived object. However, a subclass constructor may over-ride that default behaviour by redefining its @@species property.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <!-- es6num="25.4.5" -->
  <emu-clause id="sec-properties-of-the-promise-prototype-object">
    <h1>Properties of the Promise Prototype Object</h1>
    <p>The Promise prototype object is the intrinsic object <dfn>%PromisePrototype%</dfn>. The value of the [[Prototype]] internal slot of the Promise prototype object is the intrinsic object %ObjectPrototype%. The Promise prototype object is an ordinary object. It does not have a [[PromiseState]] internal slot or any of the other internal slots of Promise instances.</p>

    <!-- es6num="25.4.5.1" -->
    <emu-clause id="sec-promise.prototype.catch">
      <h1>Promise.prototype.catch ( _onRejected_ )</h1>
      <p>When the `catch` method is called with argument _onRejected_, the following steps are taken:</p>
      <emu-alg>
        1. Let _promise_ be the *this* value.
        1. Return ? Invoke(_promise_, `"then"`, &laquo; *undefined*, _onRejected_ &raquo;).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-promise.prototype.catchreturn">
      <h1><ins>Promise.prototype.catchReturn ( _onCanceled_ )</ins></h1>
      <p>When the `catchReturn` method is called with argument _onCanceled_, the following steps are taken:</p>
      <emu-alg>
        1. Let _promise_ be the *this* value.
        1. Return ? Invoke(_promise_, `"then"`, &laquo; *undefined*, *undefined*, _onCanceled_ &raquo;).
      </emu-alg>
    </emu-clause>

    <!-- es6num="25.4.5.2" -->
    <emu-clause id="sec-promise.prototype.constructor">
      <h1>Promise.prototype.constructor</h1>
      <p>The initial value of `Promise.prototype.constructor` is the intrinsic object %Promise%.</p>
    </emu-clause>

    <!-- es6num="25.4.5.3" -->
    <emu-clause id="sec-promise.prototype.then">
      <h1>Promise.prototype.then ( _onFulfilled_, _onRejected_<ins>, _onCanceled_</ins> )</h1>
      <p>When the `then` method is called with arguments _onFulfilled_<del> and _onRejected_</del><ins>, _onRejected_, and _onCanceled_</ins>, the following steps are taken:</p>
      <emu-alg>
        1. Let _promise_ be the *this* value.
        1. If IsPromise(_promise_) is *false*, throw a *TypeError* exception.
        1. Let _C_ be ? SpeciesConstructor(_promise_, %Promise%).
        1. Let _resultCapability_ be ? NewPromiseCapability(_C_).
        1. Return PerformPromiseThen(_promise_, _onFulfilled_, _onRejected_,<ins> _onCanceled_,</ins> _resultCapability_).
      </emu-alg>

      <!-- es6num="25.4.5.3.1" -->
      <emu-clause id="sec-performpromisethen" aoid="PerformPromiseThen">
        <h1>PerformPromiseThen ( _promise_, _onFulfilled_, _onRejected_,<ins> _onCanceled_,</ins> _resultCapability_ )</h1>
        <p>The abstract operation PerformPromiseThen performs the &ldquo;then&rdquo; operation on _promise_ using _onFulfilled_<del> and _onRejected_</del><ins>, _onRejected_, and _onCanceled_</ins> as its settlement actions. The result is _resultCapability_'s promise.</p>
        <emu-alg>
          1. Assert: IsPromise(_promise_) is *true*.
          1. Assert: _resultCapability_ is a PromiseCapability record.
          1. If IsCallable(_onFulfilled_) is *false*, then
            1. Let _onFulfilled_ be *undefined*.
          1. If IsCallable(_onRejected_) is *false*, then
            1. Let _onRejected_ be *undefined*.
          1. <ins>If IsCallable(_onCanceled_) is *false*, then</ins>
            1. <ins>Let _onCanceled_ be *undefined*.</ins>
          1. Let _fulfillReaction_ be the PromiseReaction { [[Capabilities]]: _resultCapability_, [[Type]]: `"Fulfill"`, [[Handler]]: _onFulfilled_ }.
          1. Let _rejectReaction_ be the PromiseReaction { [[Capabilities]]: _resultCapability_, [[Type]]: `"Reject"`, [[Handler]]: _onRejected_ }.
          1. <ins>Let _cancelReaction_ be the PromiseReaction { [[Capabilities]]: _resultCapability_, [[Type]]: `"Cancel"`, [[Handler]]: _onCanceled_ }.</ins>
          1. If the value of _promise_.[[PromiseState]] is `"pending"`, then
            1. Append _fulfillReaction_ as the last element of the List that is the value of _promise_.[[PromiseFulfillReactions]].
            1. Append _rejectReaction_ as the last element of the List that is the value of _promise_.[[PromiseRejectReactions]].
            1. <ins>Append _cancelReaction_ as the last element of the List that is the value of _promise_.[[PromiseCancelReactions]].</ins>
          1. Else if the value of _promise_.[[PromiseState]] is `"fulfilled"`, then
            1. Let _value_ be the value of _promise_.[[PromiseResult]].
            1. Perform EnqueueJob(`"PromiseJobs"`, PromiseReactionJob, &laquo; _fulfillReaction_, _value_ &raquo;).
          1. <del>Else,</del>
            1. <del>Assert: The value of _promise_.[[PromiseState]] is `"rejected"`.</del>
          1. <ins>Else if the value of _promise_.[[PromiseState]] is `"rejected"`, then</ins>
            1. Let _reason_ be the value of _promise_.[[PromiseResult]].
            1. If the value of _promise_.[[PromiseIsHandled]] is *false*, perform HostPromiseRejectionTracker(_promise_, `"handle"`).
            1. Perform EnqueueJob(`"PromiseJobs"`, PromiseReactionJob, &laquo; _rejectReaction_, _reason_ &raquo;).
          1. <ins>Otherwise the value of _promise_.[[PromiseState]] is `"canceled"`. Then:</ins>
            1. <ins>Let _cancelation_ be the value of _promise_.[[PromiseResult]].</ins>
            1. <ins>Perform EnqueueJob(`"PromiseJobs"`, PromiseReactionJob, &laquo; _cancelReaction_, _cancelation_ &raquo;).</ins>
          1. Set _promise_.[[PromiseIsHandled]] to *true*.
          1. Return _resultCapability_.[[Promise]].
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <!-- es6num="25.4.5.4" -->
    <emu-clause id="sec-promise.prototype-@@tostringtag">
      <h1>Promise.prototype [ @@toStringTag ]</h1>
      <p>The initial value of the @@toStringTag property is the String value `"Promise"`.</p>
      <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
    </emu-clause>
  </emu-clause>

  <!-- es6num="25.4.6" -->
  <emu-clause id="sec-properties-of-promise-instances">
    <h1>Properties of Promise Instances</h1>
    <p>Promise instances are ordinary objects that inherit properties from the Promise prototype object (the intrinsic, %PromisePrototype%). Promise instances are initially created with the internal slots described in <emu-xref href="#table-59"></emu-xref>.</p>
    <emu-table id="table-59" caption="Internal Slots of Promise Instances">
      <table>
        <tbody>
        <tr>
          <th>
            Internal Slot
          </th>
          <th>
            Description
          </th>
        </tr>
        <tr>
          <td>
            [[PromiseState]]
          </td>
          <td>
            A String value that governs how a promise will react to incoming calls to its `then` method. The possible values are: `"pending"`, `"fulfilled"`, <del>and `"rejected"`</del><ins>`"rejected"`, and `"canceled"`</ins>.
          </td>
        </tr>
        <tr>
          <td>
            [[PromiseResult]]
          </td>
          <td>
            The value with which the promise has been fulfilled<del> or rejected</del><ins>, rejected, or canceled</ins>, if any. Only meaningful if [[PromiseState]] is not `"pending"`.
          </td>
        </tr>
        <tr>
          <td>
            [[PromiseFulfillReactions]]
          </td>
          <td>
            A List of PromiseReaction records to be processed when/if the promise transitions from the `"pending"` state to the `"fulfilled"` state.
          </td>
        </tr>
        <tr>
          <td>
            [[PromiseRejectReactions]]
          </td>
          <td>
            A List of PromiseReaction records to be processed when/if the promise transitions from the `"pending"` state to the `"rejected"` state.
          </td>
        </tr>
        <tr>
          <td>
            <ins>[[PromiseCancelReactions]]</ins>
          </td>
          <td>
            <ins>A List of PromiseReaction records to be processed when/if the promise transitions from the `"pending"` state to the `"canceled"` state.</ins>
          </td>
        </tr>
        <tr>
          <td>
            [[PromiseIsHandled]]
          </td>
          <td>
            A boolean indicating whether the promise has ever had a fulfillment<del> or rejection</del><ins>, rejection, or cancelation</ins> handler; used in unhandled rejection tracking.
          </td>
        </tr>
        </tbody>
      </table>
    </emu-table>
  </emu-clause>
</emu-clause>
