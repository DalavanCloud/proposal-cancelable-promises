<pre class="metadata">
title: Cancelable Promises
status: proposal
stage: 1
location: https://tc39.github.io/proposal-cancelable-promises/
copyright: false
contributors: Domenic Denicola
</pre>
<script src="https://bterlson.github.io/ecmarkup/ecmarkup.js" defer></script>
<link rel="stylesheet" href="https://bterlson.github.io/ecmarkup/elements.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/solarized_light.min.css">

<emu-intro>
  <h1>Introduction</h1>

  <p>Background explanatory material for this specification can be found in the <a href="https://github.com/tc39/proposal-cancelable-promises">tc39/proposal-cancelable-promises</a> repository. See also the <a href="https://github.com/tc39/proposal-cancelable-promises/issues">issues</a>, which contain many ongoing discussions and debates.</p>
</emu-intro>

<emu-clause id="sec-promise-objects">
  <h1>Promise Objects</h1>

  <p>A Promise is an object that is used as a placeholder for the eventual results of a deferred (and possibly asynchronous) computation.</p>
  <p>Any Promise object is in one of three mutually exclusive states: <em>fulfilled</em>, <em>rejected</em>, and <em>pending</em>:</p>
  <ul>
    <li>
      A promise `p` is fulfilled if `p.then(f, r)` will immediately enqueue a Job to call the function `f`.
    </li>
    <li>
      A promise `p` is rejected if `p.then(f, r)` will immediately enqueue a Job to call the function `r`.
    </li>
    <li>
      A promise is pending if it is neither fulfilled nor rejected.
    </li>
  </ul>
  <p>A promise is said to be <em>settled</em> if it is not pending, i.e. if it is either fulfilled or rejected.</p>
  <p>A promise is <em>resolved</em> if it is settled or if it has been &ldquo;locked in&rdquo; to match the state of another promise. Attempting to resolve or reject a resolved promise has no effect. A promise is <em>unresolved</em> if it is not resolved. An unresolved promise is always in the pending state. A resolved promise may be pending, fulfilled or rejected.</p>

  <p><ins>A rejected promise is <em>canceled</em> if its rejection reason has a [[CancelBrand]] internal slot, and is <em>errored</em> otherwise.</ins></p>

  <emu-clause id="sec-promise-abstract-operations">
    <h1>Promise Abstract Operations</h1>

    <emu-clause id="sec-promisereaction-records">
      <h1>PromiseReaction Records</h1>
      <p>The PromiseReaction is a Record value used to store information about how a promise should react when it becomes resolved or rejected with a given value. PromiseReaction records are created by the PerformPromiseThen abstract operation, and are used by a PromiseReactionJob.</p>
      <p>PromiseReaction records have the fields listed in <emu-xref href="#table-58"></emu-xref>.</p>
      <emu-table id="table-58" caption="PromiseReaction Record Fields">
        <table>
          <tbody>
          <tr>
            <th>
              Field Name
            </th>
            <th>
              Value
            </th>
            <th>
              Meaning
            </th>
          </tr>
          <tr>
            <td>
              [[Capability]]
            </td>
            <td>
              A PromiseCapability Record
            </td>
            <td>
              The capabilities of the promise for which this record provides a reaction handler.
            </td>
          </tr>
          <tr>
            <td>
              [[Type]]
            </td>
            <td>
              Either `"Fulfill"`<del> or `"Reject"`</del><ins>, `"Reject"`, or `"Else"`</ins>.
            </td>
            <td>
              The [[Type]] is used when [[Handler]] is *undefined* to allow for behavior specific to the settlement type.
            </td>
          </tr>
          <tr>
            <td>
              [[Handler]]
            </td>
            <td>
              A function object or *undefined*.
            </td>
            <td>
              The function that should be applied to the incoming value, and whose return value will govern what happens to the derived promise. If [[Handler]] is *undefined*, a function that depends on the value of [[Type]] will be used instead.
            </td>
          </tr>
          </tbody>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-promise-resolve-functions">
      <h1>Promise Resolve Functions</h1>
      <p>A promise resolve function is an anonymous built-in function that has [[Promise]] and [[AlreadyResolved]] internal slots.</p>
      <p>When a promise resolve function _F_ is called with argument _resolution_, the following steps are taken:</p>
      <emu-alg>
        1. Assert: _F_ has a [[Promise]] internal slot whose value is an Object.
        1. Let _promise_ be _F_.[[Promise]].
        1. Let _alreadyResolved_ be _F_.[[AlreadyResolved]].
        1. If _alreadyResolved_.[[Value]] is *true*, return *undefined*.
        1. Set _alreadyResolved_.[[Value]] to *true*.
        1. <ins>Return ResolvePromise(_promise_, _resolution_).</ins>
        1. <del>(all previous steps have been moved to that abstract operation)</del>
      </emu-alg>
      <p>The `length` property of a promise resolve function is 1.</p>
    </emu-clause>

    <emu-clause id="sec-resolvepromise" aoid="ResolvePromise">
      <h1><ins>ResolvePromise ( _promise_, _resolution_ )</ins></h1>

      <p>When the ResolvePromise abstract operation is called with arguments _promise_ and _resolution_, the following steps are taken:</p>

      <emu-alg>
        1. If SameValue(_resolution_, _promise_) is *true*, then
          1. Let _selfResolutionError_ be a newly created *TypeError* object.
          1. Return RejectPromise(_promise_, _selfResolutionError_).
        1. If Type(_resolution_) is not Object, then
          1. Return FulfillPromise(_promise_, _resolution_).
        1. Let _then_ be Get(_resolution_, `"then"`).
        1. If _then_ is an abrupt completion, then
          1. Return RejectPromise(_promise_, _then_.[[Value]]).
        1. Let _thenAction_ be _then_.[[Value]].
        1. If IsCallable(_thenAction_) is *false*, then
          1. Return FulfillPromise(_promise_, _resolution_).
        1. Perform EnqueueJob(`"PromiseJobs"`, PromiseResolveThenableJob, &laquo; _promise_, _resolution_, _thenAction_ &raquo;).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-rejectpromise" aoid="RejectPromise">
      <h1>RejectPromise ( _promise_, _reason_ )</h1>
      <p>When the RejectPromise abstract operation is called with arguments _promise_ and _reason_, the following steps are taken:</p>
      <emu-alg>
        1. Assert: The value of _promise_.[[PromiseState]] is `"pending"`.
        1. Let _reactions_ be _promise_.[[PromiseRejectReactions]].
        1. Set _promise_.[[PromiseResult]] to _reason_.
        1. Set _promise_.[[PromiseFulfillReactions]] to *undefined*.
        1. Set _promise_.[[PromiseRejectReactions]] to *undefined*.
        1. Set _promise_.[[PromiseState]] to `"rejected"`.
        1. If _promise_.[[PromiseIsHandled]] is *false*<ins> and _reason_ has no [[CancelBrand]] internal slot</ins>, perform HostPromiseRejectionTracker(_promise_, `"reject"`).
        1. Return TriggerPromiseReactions(_reactions_, _reason_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-host-promise-rejection-tracker" aoid="HostPromiseRejectionTracker">
      <h1>HostPromiseRejectionTracker ( _promise_, _operation_ )</h1>

      <p>HostPromiseRejectionTracker is an implementation-defined abstract operation that allows host environments to track promise rejections.</p>

      <p>An implementation of HostPromiseRejectionTracker must complete normally in all cases. The default implementation of HostPromiseRejectionTracker is to unconditionally return an empty normal completion.</p>

      <emu-note>
        <p>HostPromiseRejectionTracker is called in two scenarios:</p>

        <ul>
          <li>When a promise is rejected <ins>with an object that is not a `Cancel` instance </ins>without any handlers, it is called with its _operation_ argument set to `"reject"`.</li>
          <li>When a handler is added to <ins>such </ins>a rejected promise for the first time, it is called with its _operation_ argument set to `"handle"`.</li>
        </ul>

        <p>A typical implementation of HostPromiseRejectionTracker might try to notify developers of unhandled rejections, while also being careful to notify them if such previous notifications are later invalidated by new handlers being attached.</p>
      </emu-note>

      <emu-note>
        <p>If _operation_ is `"handle"`, an implementation should not hold a reference to _promise_ in a way that would interfere with garbage collection. An implementation may hold a reference to _promise_ if _operation_ is `"reject"`, since it is expected that rejections will be rare and not on hot code paths.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-promise-jobs">
    <h1>Promise Jobs</h1>

    <emu-clause id="sec-promisereactionjob" aoid="PromiseReactionJob">
      <h1>PromiseReactionJob ( _reaction_, _argument_ )</h1>
      <p>The job PromiseReactionJob with parameters _reaction_ and _argument_ applies the appropriate handler to the incoming value, and uses the handler's return value to resolve or reject the derived promise associated with that handler.</p>
      <emu-alg>
        1. Assert: _reaction_ is a PromiseReaction Record.
        1. Let _promiseCapability_ be _reaction_.[[Capability]].
        1. Let _type_ be _reaction_.[[Type]].
        1. Let _handler_ be _reaction_.[[Handler]].
        1. <ins>If _type_ is `"Else"` and _argument_ has a [[CancelBrand]] internal slot, set _handler_ to *undefined*.</ins>
        1. If _handler_ is *undefined*, then
          1. If _type_ is `"Fulfill"`, let _handlerResult_ be NormalCompletion(_argument_).
          1. Otherwise, _type_ is `"Reject"`<ins> or `"Else"`</ins>. Let _handlerResult_ be Completion {[[Type]]: ~throw~, [[Value]]: _argument_, [[Target]]: ~empty~}.
        1. Else, let _handlerResult_ be Call(_handler_, *undefined*, &laquo; _argument_ &raquo;).
        1. If _handlerResult_ is an abrupt completion, then
          1. Let _status_ be Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; _handlerResult_.[[Value]] &raquo;).
        1. Else,
          1. Let _status_ be Call(_promiseCapability_.[[Resolve]], *undefined*, &laquo; _handlerResult_.[[Value]] &raquo;).
        1. Return Completion(_status_).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-promise-constructor">
    <h1>Properties of the Promise Constructor</h1>

    <emu-clause id="sec-promise.withcanceltoken">
      <h1><ins>Promise.withCancelToken ( _cancelToken_, _executor_ )</ins></h1>

      <emu-note>
        <p>A different name for this operation, or even the possibility of merging it into the `Promise` constructor, is under discussion in <a href="https://github.com/tc39/proposal-cancelable-promises/issues/38">#38</a>.</p>
      </emu-note>

      <p>The `withCancelToken` function returns a new promise created in a similar manner to the `Promise` constructor, but with additional abilities related to promise cancelation. If the given _cancelToken_ becomes canceled, the returned promise will become canceled in the same way, and the function returned by _executor_ (known as the "cancel action") will be called.</p>

      <emu-alg>
        1. Let _C_ be the *this* value.
        1. If _cancelToken_ is not *undefined* and ! IsCancelToken(_cancelToken_) is *false*, throw a *TypeError* exception.
        1. If IsCallable(_executor_) is *false*, throw a *TypeError* exception.
        1. Let _promiseCapability_ be ? NewPromiseCapability(_C_).
        1. Let _completion_ be Call(_executor_, *undefined*, &laquo; _promiseCapability_.[[Resolve]], _promiseCapability_.[[Reject]] &raquo;).
        1. If _completion_ is an abrupt completion, then
          1. Perform ? Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; _completion_.[[Value]] &raquo;).
          1. Return _promise_.
        1. Let _cancelAction_ be _completion_.[[Value]].
        1. If _cancelAction_ is *undefined*, return _promise_.
        1. If IsCallable(_cancelAction_) is *false*,
          1. Let _badCancelAction_ be a new *TypeError* exception.
          1. Perform ? Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; _badCancelAction_ &raquo;).
          1. Return _promise_.
        1. If _cancelToken_ is *undefined*, return _promise_.
        1. Let _throwawayCapability_ be ! NewPromiseCapability(%Promise%).
        1. Let _onFulfilled_ be a new built-in function object as defined in <emu-xref title href="#sec-promise.withcanceltoken-cancelation-reaction-functions"></emu-xref>.
        1. Set _onFulfilled_.[[CancelAction]] to _cancelAction_.
        1. Set _onFulfilled_.[[Reject]] to _promiseCapability_.[[Reject]].
        1. Perform ! PerformPromiseThen(_cancelToken_.[[CancelTokenPromise]], _onFulfilled_, *undefined*, _throwawayCapability_).
        1. Return _promise_.
      </emu-alg>

      <emu-clause id="sec-promise.withcanceltoken-cancelation-reaction-functions">
        <h1>`Promise.withCancelToken` Cancelation Reaction Functions</h1>

        <p>A `Promise.withCancelToken` cancelation reaction function is an anonymous built-in function that is used to react to a cancel token's cancelation in the `Promise.withCancelToken` function. Each `Promise.withCancelToken` cancelation reaction function has [[CancelAction]] and [[Reject]] internal slots.</p>

        <p>When a `Promise.withCancelToken` cancelation reaction function _F_ is called with argument _cancelation_, the following steps are taken:</p>

        <emu-alg>
          1. Let _cancelAction_ be _F_.[[CancelAction]].
          1. Let _reject_ be _F_.[[Reject]].
          1. Let _result_ be Call(_cancelAction_, *undefined*, &laquo; _cancelation_ &raquo;).
          1. If _result_ is an abrupt completion, perform ? Call(_reject_, *undefined*, &laquo; _result_.[[Value]] &raquo;).
          1. Otherwise, perform ? Call(_reject_, *undefined*, &laquo; _cancelation_ &raquo;).
          1. Return *undefined*.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-promise-prototype-object">
    <h1>Properties of the Promise Prototype Object</h1>
    <p>The Promise prototype object is the intrinsic object <dfn>%PromisePrototype%</dfn>. The value of the [[Prototype]] internal slot of the Promise prototype object is the intrinsic object %ObjectPrototype%. The Promise prototype object is an ordinary object. It does not have a [[PromiseState]] internal slot or any of the other internal slots of Promise instances.</p>

    <emu-clause id="sec-promise.prototype.else">
      <h1><ins>Promise.prototype.else ( _onErrored_ )</ins></h1>
      <p>When the `else` method is called with argument _onErrored_, the following steps are taken:</p>
      <emu-alg>
        1. Let _promise_ be the *this* value.
        1. If IsPromise(_promise_) is *false*, throw a *TypeError* exception.
        1. Let _C_ be ? SpeciesConstructor(_promise_, %Promise%).
        1. Let _resultCapability_ be ? NewPromiseCapability(_C_).
        1. Return PerformPromiseThen(_promise_, *undefined*, _onErrored_, _resultCapability_<ins>, `"Else"`</ins>).
      </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-promise.prototype.then">
      <h1>Promise.prototype.then ( _onFulfilled_, _onRejected_ )</h1>
      <p>When the `then` method is called with arguments _onFulfilled_ and _onRejected_, the following steps are taken:</p>
      <emu-alg>
        1. Let _promise_ be the *this* value.
        1. If IsPromise(_promise_) is *false*, throw a *TypeError* exception.
        1. Let _C_ be ? SpeciesConstructor(_promise_, %Promise%).
        1. Let _resultCapability_ be ? NewPromiseCapability(_C_).
        1. Return PerformPromiseThen(_promise_, _onFulfilled_, _onRejected_, _resultCapability_<ins>, `"Rejected"`</ins>).
      </emu-alg>

      <!-- es6num="25.4.5.3.1" -->
      <emu-clause id="sec-performpromisethen" aoid="PerformPromiseThen">
        <h1>PerformPromiseThen ( _promise_, _onFulfilled_, _onRejected_, _resultCapability_<ins>, _rejectReactionType_</ins> )</h1>
        <p>The abstract operation PerformPromiseThen performs the &ldquo;then&rdquo; operation on _promise_ using _onFulfilled_ and _onRejected_ as its settlement actions<ins> (with _onRejected_'s behavior being further modified by _rejectReactionType_)</ins>. The result is _resultCapability_'s promise.</p>
        <emu-alg>
          1. Assert: IsPromise(_promise_) is *true*.
          1. Assert: _resultCapability_ is a PromiseCapability Record.
          1. If IsCallable(_onFulfilled_) is *false*, then
            1. Let _onFulfilled_ be *undefined*.
          1. If IsCallable(_onRejected_) is *false*, then
            1. Let _onRejected_ be *undefined*.
          1. Let _fulfillReaction_ be the PromiseReaction { [[Capability]]: _resultCapability_, [[Type]]: `"Fulfill"`, [[Handler]]: _onFulfilled_ }.
          1. Let _rejectReaction_ be the PromiseReaction { [[Capability]]: _resultCapability_, [[Type]]: <del>`"Reject"`</del><ins>_rejectReactionType_</ins>, [[Handler]]: _onRejected_ }.
          1. If _promise_.[[PromiseState]] is `"pending"`, then
            1. Append _fulfillReaction_ as the last element of the List that is _promise_.[[PromiseFulfillReactions]].
            1. Append _rejectReaction_ as the last element of the List that is _promise_.[[PromiseRejectReactions]].
          1. Else if _promise_.[[PromiseState]] is `"fulfilled"`, then
            1. Let _value_ be _promise_.[[PromiseResult]].
            1. Perform EnqueueJob(`"PromiseJobs"`, PromiseReactionJob, &laquo; _fulfillReaction_, _value_ &raquo;).
          1. Else,
            1. Assert: The value of _promise_.[[PromiseState]] is `"rejected"`.
            1. Let _reason_ be _promise_.[[PromiseResult]].
            1. If _promise_.[[PromiseIsHandled]] is *false*<ins> and _reason_ does not have a [[CancelBrand]] internal slot</ins>, perform HostPromiseRejectionTracker(_promise_, `"handle"`).
            1. Perform EnqueueJob(`"PromiseJobs"`, PromiseReactionJob, &laquo; _rejectReaction_, _reason_ &raquo;).
          1. Set _promise_.[[PromiseIsHandled]] to *true*.
          1. Return _resultCapability_.[[Promise]].
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-cancel-objects">
  <h1><ins>Cancel Objects</ins></h1>

  <p>Instances of Cancel objects are thrown as exceptions when an operations has been canceled. They do not indicate a runtime error, and are treated differently from other exceptions in several places in this specification.</p>

  <emu-clause id="sec-cancel-constructor">
    <h1>The Cancel Constructor</h1>

    <p>The Cancel constructor is the <dfn>%Cancel%</dfn> intrinsic object and the initial value of the `Cancel` property of the global object. When `Cancel` is called as a function rather than as a constructor, it creates and initializes a new Cancel object. Thus the function call `Cancel(&hellip;)` is equivalent to the object creation expression `new Cancel(&hellip;)` with the same arguments.</p>

    <p>The `Cancel` constructor is designed to be subclassable. It may be used as the value of an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified `Cancel` behaviour must include a `super` call to the `Cancel` constructor to create and initialize subclass instances with a [[CancelBrand]] internal slot.</p>

    <emu-clause id="sec-cancel-message">
      <h1>Cancel ( _message_ )</h1>

      <p>When the `Cancel` function is called with argument _message_, the following steps are taken:</p>

      <emu-alg>
        1. If NewTarget is *undefined*, let _newTarget_ be the active function object, else let _newTarget_ be NewTarget.
        1. Let _O_ be ? OrdinaryCreateFromConstructor(_newTarget_, `"%CancelPrototype%"`, &laquo; [[CancelBrand]] &raquo;).
        1. If _message_ is not *undefined*, then
          1. Let _msg_ be ? ToString(_message_).
          1. Let _msgDesc_ be the PropertyDescriptor { [[Value]]: _msg_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.
          1. Perform ! DefinePropertyOrThrow(_O_, `"message"`, _msgDesc_).
        1. Return _O_.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-cancel-constructor">
    <h1>Properties of the Cancel Constructor</h1>

    <p>The value of the [[Prototype]] internal slot of the Cancel constructor is the intrinsic object %FunctionPrototype%.</p>

    <p>The Cancel constructor has the following properties:</p>

    <emu-clause id="sec-cancel.prototype">
      <h1>Cancel.prototype</h1>
      <p>The initial value of `Cancel.prototype` is the intrinsic object %CancelPrototype%.</p>
      <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-cancel-prototype-object">
    <h1>Properties of the Cancel Prototype Object</h1>

    <p>The Cancel prototype object is the intrinsic object <dfn>%CancelPrototype%</dfn>. The Cancel prototype object is an ordinary object. It is not a Cancel instance and does not have a [[CancelBrand]] internal slot.</p>

    <p>The value of the [[Prototype]] internal slot of the Cancel prototype object is the intrinsic object %ObjectPrototype%.</p>

    <emu-clause id="sec-cancel.prototype.constructor">
      <h1>Cancel.prototype.constructor</h1>
      <p>The initial value of `Cancel.prototype.constructor` is the intrinsic object %Cancel%.</p>
    </emu-clause>

    <emu-clause id="sec-cancel.prototype.tostring">
      <h1>Cancel.prototype.toString ( )</h1>
      <p>The following steps are taken:</p>
      <emu-alg>
        1. Let _O_ be the *this* value.
        1. If Type(_O_) is not Object, throw a *TypeError* exception.
        1. Let _msg_ be ? Get(_O_, `"message"`).
        1. If _msg_ is *undefined*, let _msg_ be the empty String; otherwise let _msg_ be ? ToString(_msg_).
        1. If _msg_ is the empty String, return `"Cancel"`.
        1. Return the result of concatenating `"Cancel: "` and _msg_.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-cancel-instances">
    <h1>Properties of Cancel Instances</h1>
    <p>Cancel instances are ordinary objects that inherit properties from the Cancel prototype object and have a [[CancelBrand]] internal slot whose value is *undefined*. The only use of [[CancelBrand]] is to identify Cancel instances; its actual value is not important and it does not store any data.</p>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-canceltoken-objects">
  <h1><ins>CancelToken Objects</ins></h1>

  <p>A cancel token is an object that allows its consumer to monitor and respond to requests for cancelation of an ongoing operation.</p>

  <emu-clause id="sec-canceltoken-abstract-operations">
    <h1>CancelToken Abstract Operations</h1>

    <emu-clause id="sec-cancel-cancel-token" aoid="CancelCancelToken">
      <h1>CancelCancelToken ( _cancelToken_, _message_ )</h1>

      <p>When the CancelCancelToken abstract operation is called with arguments _cancelToken_ and _message_, the following steps are taken:</p>

      <emu-alg>
        1. Let _promise_ be _cancelToken_.[[CancelTokenPromise]].
        1. Let _cancelation_ be ? Construct(%Cancel%, &laquo; _cancelMessage_ &raquo;).
        1. Perform ! ResolvePromise(_promise_, _cancelation_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-cancel-token-reason" aoid="CancelTokenReason">
      <h1>CancelTokenReason ( _cancelToken_ )</h1>

      <p>The abstract operation CancelTokenReason returns the cancel token's cancelation reason.</p>

      <emu-alg>
        1. Assert: ! IsCancelToken(_cancelToken_) is *true*.
        1. If _cancelToken_.[[CancelTokenPromise]].[[PromiseState]] is not `"fulfilled"`, return *undefined*.
        1. Let _reason_ be _cancelToken_.[[CancelTokenPromise]].[[PromiseResult]].
        1. Assert: _reason_ has a [[CancelBrand]] internal slot.
        1. Return _reason_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-is-cancel-token" aoid="IsCancelToken">
      <h1>IsCancelToken ( _x_ )</h1>

      <p>The abstract operation IsCancelToken checks for the cancel token brand on an object.</p>

      <emu-alg>
        1. If Type(_x_) is not Object, return *false*.
        1. If _x_ does not have a [[CancelTokenPromise]] internal slot, return *false*.
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-new-cancel-token-source" aoid="NewCancelTokenSource">
      <h1>NewCancelTokenSource ( _C_ )</h1>

      <p>The abstract operation NewCancelTokenSource takes a constructor function, and attempts to use that constructor function in the fashion of the built-in `CancelToken` constructor to create a cancel token and extract its cancel function. The cancel token plus its cancel function is used to initialize a new Record which is returned.</p>

      <emu-alg>
        1. If IsConstructor(_C_) is *false*, throw a *TypeError* exception.
        1. Let _source_ be a new Record { [[Token]]: *undefined*, [[Cancel]]: *undefined* }.
        1. Let _executor_ be a new built-in function object as defined in <emu-xref href="#sec-getcancelexecutor-functions" title></emu-xref>.
        1. Set _executor_.[[Source]] to _source_.
        1. Let _token_ be ? Construct(_C_, &laquo; _executor_ &raquo;).
        1. Set _source_.[[Token]] to _token_.
        1. Return _source_.
      </emu-alg>

      <emu-clause id="sec-getcancelexecutor-functions">
        <h1>GetCancelExecutor Functions</h1>

        <p>A GetCancelExecutor function is an anonymous built-in function that has a [[Source]] internal slot.</p>

        <p>When a GetCancelExecutor function _F_ is called with argument _cancel_, the following steps are taken:</p>

        <emu-alg>
          1. Assert: _F_ has a [[Source]] internal slot whose value is a Record containing a field [[Cancel]].
          1. Let _source_ be _F_.[[Source]].
          1. Set _source_.[[Cancel]] to _cancel_.
          1. Return *undefined*.
        </emu-alg>

        <p>The `length` property of a GetCancelExecutor function is 1.</p>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-canceltoken-constructor">
    <h1>The CancelToken Constructor</h1>

    <p>The CancelToken constructor is the <dfn>%CancelToken%</dfn> intrinsic object and the initial value of the `CancelToken` property of the global object. When called as a constructor, it creates and initializes as a new CancelToken object. `CancelToken` is not intended to be called as a function and will throw an exception when called in that manner.</p>

    <p>The `CancelToken` constructor is designed to be subclassable. It may be used as the value in an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified `CancelToken` behaviour must include a `super` call to the `CancelToken` constructor to create and initialize the subclass instance with the internal state necessary to support the `CancelToken` and `CancelToken.prototype` built-in methods.</p>

    <emu-clause id="sec-canceltoken-constructor-definition">
      <h1>CancelToken ( _executor_ )</h1>

      <p>When the `CancelToken` function is called with argument _executor_, the following steps are taken:</p>

      <emu-alg>
        1. If NewTarget is *undefined*, throw a *TypeError* exception.
        1. If IsCallable(_executor_) is *false*, throw a *TypeError* exception.
        1. Let _cancelToken_ be ? OrdinaryCreateFromConstructor(NewTarget, `"%CancelTokenPrototype"`, &laquo; [[CancelTokenPromise]] &raquo;).
        1. Let _dummyExecutor_ be an anonymous built-in function of no arguments that does nothing besides return *undefined*.
        1. Let _promise_ be ! Construct(%Promise%, &laquo; _dummyExecutor_ &raquo;).
        1. Set _cancelToken_.[[CancelTokenPromise]] to _promise_.
        1. Let _cancel_ be a new built-in function object as defined in <emu-xref href="#sec-canceler-functions" title></emu-xref>.
        1. Set _cancel_.[[CancelToken]] to _cancelToken_.
        1. Perform ? Call(_executor_, *undefined*, &laquo; _cancel_ &raquo;).
        1. Return _cancelToken_.
      </emu-alg>

      <emu-note>
        <p>The _executor_ argument must be a function object. It is called to vend the ability to send the cancelation token into a canceled state, via its single argument, _cancel_.</p>
        <p>The _cancel_ function that is passed to an _executor_ function accepts a single argument. The _executor_ code may eventually call the _cancel_ function indicate it wishes to request cancelation. The argument passed to the _cancel_ function represents the cancelation. If it is not a "thenable" value, cancelation will be requested immediately; otherwise, cancelation will be requested once the passed thenable fulfills.</p>
      </emu-note>

      <emu-clause id="sec-canceler-functions">
        <h1>Canceler Functions</h1>

        <p>A Canceler function is an anonymous built-in function that has a [[CancelToken]] internal slot.</p>

        <p>When a Canceler function _F_ is called with argument _cancelMessage_, the following steps are taken:</p>

        <emu-alg>
          1. Assert: _F_ has a [[CancelToken]] internal slot whose value is an instance of the intrinsic %CancelToken%.
          1. Let _cancelToken_ be _F_.[[CancelToken]].
          1. Return CancelCancelToken(_cancelToken_, _cancelMessage_).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-canceltoken-constructor">
    <h1>Properties of the CancelToken Constructor</h1>

    <p>The value of the [[Prototype]] internal slot of the `CancelToken` constructor is the intrinsic object %CancelTokenPrototype%.</p>

    <p>The CancelToken constructor has the following properties:</p>

    <emu-clause id="sec-canceltoken.source">
      <h1>CancelToken.source ( )</h1>

      <p>The `source()` function returns an object with two properties, `token` and `cancel`, which respectively give a newly-created cancel token, and the ability to request cancelation for that token. It is a convenient alternative to the `CancelToken` constructor.</p>

      <emu-alg>
        1. Let _C_ be the *this* value.
        1. Let _source_ be ? NewCancelTokenSource(_C_).
        1. Let _result_ be ! ObjectCreate(%ObjectPrototype%).
        1. Perform ! CreateDataProperty(_result_, `"token"`, _source_.[[Token]]).
        1. Perform ! CreateDataProperty(_result_, `"cancel"`, _source_.[[Cancel]]).
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-canceltoken.race">
      <h1>CancelToken.race ( _iterable_ )</h1>

      <p>The `race` function returns a new cancel token which becomes canceled in the same way as the first passed cancel token to become canceled. If _iterable_ contains any elements that are not cancel tokens, the function throws a *TypeError* exception.</p>

      <emu-alg>
        1. Let _C_ be the *this* value.
        1. Let _source_ be ? NewCancelTokenSource(_C_).
        1. Let _tokens_ be ? IterableToList(_iterable_).
        1. For each element _token_ of _tokens_,
          1. If ! IsCancelToken(_token_) is *false*, throw a *TypeError* exception.
        1. For each element _token_ of _tokens_,
          1. Let _reason_ be CancelTokenReason(_token_).
          1. If _reason_ is not *undefined*,
            1. Perform ? Call(_source_.[[Cancel]], *undefined*, &laquo; _reason_ &raquo;).
            1. Return _source_.[[Token]].
        1. For each element _token_ of _tokens_,
          1. Let _throwawayCapability_ be ! NewPromiseCapability(%Promise%).
          1. Perform ! PerformPromiseThen(_token_.[[CancelTokenPromise]], _source_.[[Cancel]], *undefined*, _throwawayCapability_).
        1. Return _source_.[[Token]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-canceltoken.prototype">
      <h1>CancelToken.prototype</h1>

      <p>The initial value of `CancelToken.prototype` is the intrinsic object %CancelTokenPrototype%.</p>

      <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-canceltoken-prototype-object">
    <h1>Properties of the CancelToken Prototype Object</h1>

    <p>The CancelToken prototype object is the intrinsic object <dfn>%CancelTokenPrototype%</dfn>. The value of the [[Prototype]] internal slot of the CancelToken prototype object is the intrinsic object %ObjectPrototype%. The CancelToken prototype object is an ordinary object. It does not have a [[CancelTokenPromise]] internal slot or any of the other internal slots of CancelToken instances.</p>

    <emu-clause id="sec-canceltoken.prototype.throwifrequested">
      <h1>CancelToken.prototype.throwIfRequested ( )</h1>

      <p>When the `throwIfRequested` method is called, the following steps are taken:</p>

      <emu-alg>
        1. Let _T_ be the *this* value.
        1. If ! IsCancelToken(_T_) is *false*, throw a *TypeError* exception.
        1. Let _reason_ be ! CancelTokenReason(_T_).
        1. If _reason_ is not *undefined*, return Completion { [[Type]]: ~throw~, [[Value]]: _reason_, [[Target]]: ~empty~ }.
        1. Return *undefined*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-canceltoken.prototype.constructor">
      <h1>CancelToken.prototype.constructor</h1>

      <p>The initial value of `CancelToken.prototype.constructor` is the intrinsic object %CancelToken%.</p>
    </emu-clause>

    <emu-clause id="sec-canceltoken.prototype.promise">
      <h1>get CancelToken.prototype.promise</h1>

      <p>`CancelToken.prototype.promise` is an accessor property whose set accessor is *undefined*. Its get accessor function performs the following steps:</p>

      <emu-alg>
        1. Let _T_ be the *this* value.
        1. If ! IsCancelToken(_T_) is *false*, throw a *TypeError* exception.
        1. Return _T_.[[CancelTokenPromise]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-canceltoken.prototype.reason">
      <h1>get CancelToken.prototype.reason</h1>

      <p>`CancelToken.prototype.reason` is an accessor property whose set accessor is *undefined*. Its get accessor function performs the following steps:</p>

      <emu-alg>
        1. Let _T_ be the *this* value.
        1. If ! IsCancelToken(_T_) is *false*, throw a *TypeError* exception.
        1. Return ! CancelTokenReason(_T_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-canceltoken.prototype-@@tostringtag">
      <h1>CancelToken.prototype [ @@toStringTag ]</h1>
      <p>The initial value of the @@toStringTag property is the String value `"CancelToken"`.</p>
      <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-canceltoken-instances">
    <h1>Properties of CancelToken Instances</h1>

    <p>CancelToken instances are ordinary objects that inherit properties from the CancelToken prototype object (the intrinsic, %CancelTokenPrototype%). CancelToken instances are initially created with the internal slots described in <emu-xref href="#table-canceltoken-internal-slots"></emu-xref>.</p>

    <emu-table id="table-canceltoken-internal-slots" caption="Internal Slots of CancelToken Instances">
      <table>
        <thead>
          <tr>
            <th>Internal Slot</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>[[CancelTokenPromise]]</td>
            <td>A Promise object (always an instance of the intrinsic, %Promise%) which will be fulfilled when/if cancelation is requested.
          </tr>
        </tbody>
      </table>
    </emu-table>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-statements-and-declarations">
  <h1>ECMAScript Language: Statements and Declarations</h1>

  <emu-clause id="sec-try-statement">
    <h1>The `try` Statement</h1>
    <h2>Syntax</h2>
    <emu-grammar>
      TryStatement[Yield, Return] :
        `try` Block[?Yield, ?Return] Catch[?Yield, ?Return]
        <ins>`try` Block[?Yield, ?Return] Else[?Yield, ?Return]</ins>
        `try` Block[?Yield, ?Return] Finally[?Yield, ?Return]
        `try` Block[?Yield, ?Return] Catch[?Yield, ?Return] Finally[?Yield, ?Return]
        <ins>`try` Block[?Yield, ?Return] Else[?Yield, ?Return] Finally[?Yield, ?Return]</ins>

      Catch[Yield, Return] :
        `catch` `(` CatchParameter[?Yield] `)` Block[?Yield, ?Return]

      <ins>Else[Yield, Return] :
        `else` `(` CatchParameter[?Yield] `)` Block[?Yield, ?Return]</ins>

      Finally[Yield, Return] :
        `finally` Block[?Yield, ?Return]

      CatchParameter[Yield] :
        BindingIdentifier[?Yield]
        BindingPattern[?Yield]
    </emu-grammar>
    <emu-note>
      <p>The `try` statement encloses a block of code in which an exceptional condition can occur, such as a runtime error or a `throw` statement. The `catch` clause provides the exception-handling code. When a `catch` clause catches an exception, its |CatchParameter| is bound to that exception. <ins>The `else` clause provides error-handling code. It behaves identically to a `catch` clause, except that it does not catch cancelations (i.e. `Cancel` objects).</p>
    </emu-note>

    <!-- es6num="13.15.1" -->
    <emu-clause id="sec-try-statement-static-semantics-early-errors">
      <h1>Static Semantics: Early Errors</h1>
      <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if BoundNames of |CatchParameter| contains any duplicate elements.
        </li>
        <li>
          It is a Syntax Error if any element of the BoundNames of |CatchParameter| also occurs in the LexicallyDeclaredNames of |Block|.
        </li>
        <li>
          It is a Syntax Error if any element of the BoundNames of |CatchParameter| also occurs in the VarDeclaredNames of |Block|.
        </li>
      </ul>
      <emu-note>
        <p>An alternative static semantics for this production is given in <emu-xref href="#sec-variablestatements-in-catch-blocks"></emu-xref>.</p>
      </emu-note>

      <ins><emu-grammar>Else : `else` `(` CatchParameter `)` Block</emu-grammar></ins>
      <ul>
        <li>
          <ins>It is a Syntax Error if BoundNames of |CatchParameter| contains any duplicate elements.</ins>
        </li>
        <li>
          <ins>It is a Syntax Error if any element of the BoundNames of |CatchParameter| also occurs in the LexicallyDeclaredNames of |Block|.</ins>
        </li>
        <li>
          <ins>It is a Syntax Error if any element of the BoundNames of |CatchParameter| also occurs in the VarDeclaredNames of |Block|.</ins>
        </li>
      </ul>

      <emu-note>
        <p><ins>The alternative static semantics for `catch` do not apply to `else`.</ins></p>
      </emu-note>
    </emu-clause>

    <!-- es6num="13.15.2" -->
    <emu-clause id="sec-try-statement-static-semantics-containsduplicatelabels">
      <h1>Static Semantics: ContainsDuplicateLabels</h1>
      <p>With argument _labelSet_.</p>
      <emu-see-also-para op="ContainsDuplicateLabels"></emu-see-also-para>

      <emu-grammar>TryStatement : `try` Block Catch</emu-grammar>
      <emu-alg>
        1. Let _hasDuplicates_ be ContainsDuplicateLabels of |Block| with argument _labelSet_.
        1. If _hasDuplicates_ is *true*, return *true*.
        1. Return ContainsDuplicateLabels of |Catch| with argument _labelSet_.
      </emu-alg>

      <ins><emu-grammar>TryStatement : `try` Block Else</emu-grammar></ins>
      <emu-alg>
        1. <ins>Let _hasDuplicates_ be ContainsDuplicateLabels of |Block| with argument _labelSet_.</ins>
        1. <ins>If _hasDuplicates_ is *true*, return *true*.</ins>
        1. <ins>Return ContainsDuplicateLabels of |Else| with argument _labelSet_.</ins>
      </emu-alg>

      <emu-grammar>TryStatement : `try` Block Finally</emu-grammar>
      <emu-alg>
        1. Let _hasDuplicates_ be ContainsDuplicateLabels of |Block| with argument _labelSet_.
        1. If _hasDuplicates_ is *true*, return *true*.
        1. Return ContainsDuplicateLabels of |Finally| with argument _labelSet_.
      </emu-alg>

      <emu-grammar>TryStatement : `try` Block Catch Finally</emu-grammar>
      <emu-alg>
        1. Let _hasDuplicates_ be ContainsDuplicateLabels of |Block| with argument _labelSet_.
        1. If _hasDuplicates_ is *true*, return *true*.
        1. Let _hasDuplicates_ be ContainsDuplicateLabels of |Catch| with argument _labelSet_.
        1. If _hasDuplicates_ is *true*, return *true*.
        1. Return ContainsDuplicateLabels of |Finally| with argument _labelSet_.
      </emu-alg>

      <emu-grammar><ins>TryStatement : `try` Block Else Finally</ins></emu-grammar>
      <emu-alg>
        1. <ins>Let _hasDuplicates_ be ContainsDuplicateLabels of |Block| with argument _labelSet_.</ins>
        1. <ins>If _hasDuplicates_ is *true*, return *true*.</ins>
        1. <ins>Let _hasDuplicates_ be ContainsDuplicateLabels of |Else| with argument _labelSet_.</ins>
        1. <ins>If _hasDuplicates_ is *true*, return *true*.</ins>
        1. <ins>Return ContainsDuplicateLabels of |Finally| with argument _labelSet_.</ins>
      </emu-alg>

      <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar>
      <emu-alg>
        1. Return ContainsDuplicateLabels of |Block| with argument _labelSet_.
      </emu-alg>

      <emu-grammar><ins>Else : `else` `(` CatchParameter `)` Block</ins></emu-grammar>
      <emu-alg>
        1. <ins>Return ContainsDuplicateLabels of |Block| with argument _labelSet_.</ins>
      </emu-alg>
    </emu-clause>

    <!-- es6num="13.15.3" -->
    <emu-clause id="sec-try-statement-static-semantics-containsundefinedbreaktarget">
      <h1>Static Semantics: ContainsUndefinedBreakTarget</h1>

      <p><ins>Modifications are analogous to those for ContainsDuplicateLabels.</ins></p>
    </emu-clause>

    <!-- es6num="13.15.4" -->
    <emu-clause id="sec-try-statement-static-semantics-containsundefinedcontinuetarget">
      <h1>Static Semantics: ContainsUndefinedContinueTarget</h1>

      <p><ins>Modifications are analogous to those for ContainsDuplicateLabels.</ins></p>
    </emu-clause>

    <!-- es6num="13.15.5" -->
    <emu-clause id="sec-try-statement-static-semantics-vardeclarednames">
      <h1>Static Semantics: VarDeclaredNames</h1>

      <p><ins>Modifications are analogous to those for ContainsDuplicateLabels.</ins></p>
    </emu-clause>

    <!-- es6num="13.15.6" -->
    <emu-clause id="sec-try-statement-static-semantics-varscopeddeclarations">
      <h1>Static Semantics: VarScopedDeclarations</h1>

      <p><ins>Modifications are analogous to those for ContainsDuplicateLabels.</ins></p>
    </emu-clause>

    <!-- es6num="13.15.7" -->
    <emu-clause id="sec-runtime-semantics-catchclauseevaluation">
      <h1>Runtime Semantics: CatchClauseEvaluation</h1>
      <p>with parameter _thrownValue_</p>
      <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar>
      <emu-grammar><ins>Else : `else` `(` CatchParameter `)` Block</ins></emu-grammar>
      <emu-alg>
        1. Let _oldEnv_ be the running execution context's LexicalEnvironment.
        1. Let _catchEnv_ be NewDeclarativeEnvironment(_oldEnv_).
        1. Let _catchEnvRec_ be _catchEnv_'s EnvironmentRecord.
        1. For each element _argName_ of the BoundNames of |CatchParameter|, do
          1. Perform ! _catchEnvRec_.CreateMutableBinding(_argName_, *false*).
        1. Set the running execution context's LexicalEnvironment to _catchEnv_.
        1. Let _status_ be the result of performing BindingInitialization for |CatchParameter| passing _thrownValue_ and _catchEnv_ as arguments.
        1. If _status_ is an abrupt completion, then
          1. Set the running execution context's LexicalEnvironment to _oldEnv_.
          1. Return Completion(_status_).
        1. Let _B_ be the result of evaluating |Block|.
        1. Set the running execution context's LexicalEnvironment to _oldEnv_.
        1. Return Completion(_B_).
      </emu-alg>
      <emu-note>
        <p>No matter how control leaves the |Block| the LexicalEnvironment is always restored to its former state.</p>
      </emu-note>
      <emu-note>
        <p><ins>|Else| and |Catch| have the same runtime semantics for CatchClauseEvaluation. However, the runtime semantics for |Try| invoke CatchClauseEvaluation differently in each case depending on the thrown exception.</ins></p>
      </emu-note>
    </emu-clause>

    <!-- es6num="13.15.8" -->
    <emu-clause id="sec-try-statement-runtime-semantics-evaluation">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>TryStatement : `try` Block Catch</emu-grammar>
      <emu-alg>
        1. Let _B_ be the result of evaluating |Block|.
        1. If _B_.[[Type]] is ~throw~, let _C_ be CatchClauseEvaluation of |Catch| with parameter _B_.[[Value]].
        1. Else, let _C_ be _B_.
        1. Return Completion(UpdateEmpty(_C_, *undefined*)).
      </emu-alg>

      <ins><emu-grammar>TryStatement : `try` Block Else</emu-grammar>
      <emu-alg>
        1. <ins>Let _B_ be the result of evaluating |Block|.</ins>
        1. <ins>If _B_.[[Type]] is ~throw~ and _B_.[[Value]] does not have a [[CancelBrand]] internal slot, let _C_ be CatchClauseEvaluation of |Else| with parameter _B_.[[Value]].</ins>
        1. <ins>Else, let _C_ be _B_.</ins>
        1. <ins>Return Completion(UpdateEmpty(_C_, *undefined*)).</ins>
      </emu-alg>

      <emu-grammar>TryStatement : `try` Block Finally</emu-grammar>
      <emu-alg>
        1. Let _B_ be the result of evaluating |Block|.
        1. Let _F_ be the result of evaluating |Finally|.
        1. If _F_.[[Type]] is ~normal~, let _F_ be _B_.
        1. Return Completion(UpdateEmpty(_F_, *undefined*)).
      </emu-alg>

      <emu-grammar>TryStatement : `try` Block Catch Finally</emu-grammar>
      <emu-alg>
        1. Let _B_ be the result of evaluating |Block|.
        1. If _B_.[[Type]] is ~throw~, let _C_ be CatchClauseEvaluation of |Catch| with parameter _B_.[[Value]].
        1. Else, let _C_ be _B_.
        1. Let _F_ be the result of evaluating |Finally|.
        1. If _F_.[[Type]] is ~normal~, let _F_ be _C_.
        1. Return Completion(UpdateEmpty(_F_, *undefined*)).
      </emu-alg>

      <ins><emu-grammar>TryStatement : `try` Block Else Finally</emu-grammar></ins>
      <emu-alg>
        1. <ins>Let _B_ be the result of evaluating |Block|.</ins>
        1. <ins>If _B_.[[Type]] is ~throw~ and _B_.[[Value]] does not have a [[CancelBrand]] internal slot, let _C_ be CatchClauseEvaluation of |Else| with parameter _B_.[[Value]].</ins>
        1. <ins>Else, let _C_ be _B_.</ins>
        1. <ins>Let _F_ be the result of evaluating |Finally|.</ins>
        1. <ins>If _F_.[[Type]] is ~normal~, let _F_ be _C_.</ins>
        1. <ins>Return Completion(UpdateEmpty(_F_, *undefined*)).</ins>
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-await-canceltoken">
  <h1><code>await.cancelToken</code> Modifications</h1>

  <emu-note>
    <p>This section describes the modifications to the <a href="https://tc39.github.io/ecmascript-asyncawait/">async functions</a> proposal, and surrounding machinery, necessary to implement the <code>await.cancelToken</code> feature. The CancelCancelToken abstract operation is also part of this process.</p>
  </emu-note>

  <emu-clause id="sec-execution-contexts">
    <h1>Execution Contexts</h1>
    <emu-note>
      <p>Existing contents of the <a href="https://tc39.github.io/ecma262/#sec-execution-contexts">Execution Contexts</a> sections are unchanged. The following is to be inserted following the table "Additional State Components for Generator Execution Contexts".</p>

      <p><ins>Execution contexts representing the evaluation of async functions have the additional state components listed in <emu-xref href="#table-additional-async-function-execution-context-state"></emu-xref>.</ins></p>

      <emu-table id="table-additional-async-function-execution-context-state" caption="Additional State Components for Async Function Execution Contexts">
        <table>
          <thead>
            <tr>
              <th>Component</th>
              <th>Purpose</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>CancelToken</td>
              <td>The CancelToken object which controls the cancelation of <code>await</code> expressions, or *undefined* if there is no such CancelToken.</td>
            </tr>
          </tbody>
        </table>
      </emu-table>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-left-hand-side-expressions">
    <h1>Left-Hand-Side Expressions</h1>

    <h2>Syntax</h2>
    <emu-grammar>
      MemberExpression[Yield] :
        PrimaryExpression[?Yield]
        MemberExpression[?Yield] `[` Expression[+In, ?Yield] `]`
        MemberExpression[?Yield] `.` IdentifierName
        MemberExpression[?Yield] TemplateLiteral[?Yield]
        SuperProperty[?Yield]
        MetaProperty
        `new` MemberExpression[?Yield] Arguments[?Yield]

      SuperProperty[Yield] :
        `super` `[` Expression[+In, ?Yield] `]`
        `super` `.` IdentifierName

      <del>MetaProperty :</del>
        <del>NewTarget</del>

      <ins>MetaProperty[Await] :</ins>
        <ins>NewTarget</ins>
        <ins>[+Await] AwaitCancelToken</ins>

      NewTarget :
        `new` `.` `target`

      <ins>AwaitCancelToken :
        `await` `.` `cancelToken`</ins>

      NewExpression[Yield] :
        MemberExpression[?Yield]
        `new` NewExpression[?Yield]

      CallExpression[Yield] :
        MemberExpression[?Yield] Arguments[?Yield]
        SuperCall[?Yield]
        CallExpression[?Yield] Arguments[?Yield]
        CallExpression[?Yield] `[` Expression[+In, ?Yield] `]`
        CallExpression[?Yield] `.` IdentifierName
        CallExpression[?Yield] TemplateLiteral[?Yield]

      SuperCall[Yield] :
        `super` Arguments[?Yield]

      Arguments[Yield] :
        `(` `)`
        `(` ArgumentList[?Yield] `)`

      ArgumentList[Yield] :
        AssignmentExpression[+In, ?Yield]
        `...` AssignmentExpression[+In, ?Yield]
        ArgumentList[?Yield] `,` AssignmentExpression[+In, ?Yield]
        ArgumentList[?Yield] `,` `...` AssignmentExpression[+In, ?Yield]

      LeftHandSideExpression[Yield] :
        NewExpression[?Yield]
        CallExpression[?Yield]
    </emu-grammar>

    <emu-clause id="sec-meta-properties">
      <h1>Meta Properties</h1>

      <emu-clause id="sec-meta-properties-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>NewTarget : `new` `.` `target`</emu-grammar>
        <emu-alg>
          1. Return GetNewTarget().
        </emu-alg>

        <emu-grammar><ins>AwaitCancelToken : `await` `.` `cancelToken`</ins></emu-grammar>
        <emu-alg>
          1. If the code matched by the syntactic production that is being evaluated is strict mode code, let _strict_ be *true*, else let _strict_ be *false*.
          1. Return ? MakeAwaitCancelTokenReference(_strict_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-makeawaitcanceltokenreference" aoid="MakeAwaitCancelTokenReference">
        <h1>Runtime Semantics: MakeAwaitCancelTokenReference(_strict_)</h1>

        <p>The abstract operation MakeAwaitCancelTokenReference with argument _strict_ performs the following steps:</p>

        <emu-alg>
          1. Let _runningContext_ be the running execution context.
          1. If _runningContext_ does not have a CancelToken component, throw a *ReferenceError* exception.
          1. Return a value of type Reference that is an Await Cancel Token Reference whose base value component is _runningContext_, whose referenced name component is `""`, and whose strict reference flag is _strict_.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-reference-specification-type">
    <h1>The Reference Specification Type</h1>
    <emu-note>
      <p>The Reference type is used to explain the behaviour of such operators as `delete`, `typeof`, the assignment operators, the `super` keyword<ins>, the `await.cancelToken` meta-property,</ins> and other language features. For example, the left-hand operand of an assignment is expected to produce a reference.</p>
    </emu-note>
    <p>A <dfn>Reference</dfn> is a resolved name or property binding. A Reference consists of three components, the base value component, the referenced name component, and the Boolean-valued strict reference flag. The base value component is either *undefined*, an Object, a Boolean, a String, a Symbol, a Number, an Environment Record, or an execution context. A base value component of *undefined* indicates that the Reference could not be resolved to a binding. The referenced name component is a String or Symbol value.</p>
    <p>A <dfn id="super-reference">Super Reference</dfn> is a Reference that is used to represents a name binding that was expressed using the `super` keyword. A Super Reference has an additional thisValue component, and its base value component will never be an Environment Record.</p>
    <p><ins>An <dfn id="await-cancel-token-reference">Await Cancel Token Reference</dfn> is a Reference that is used to represent the assignable binding expressed using the `await.cancelToken` meta-property. An Await Cancel Token Reference's base value component is always an execution context.</ins></p>

    <p>The following abstract operations are used in this specification to access the components of references:</p>
    <ul>
      <li>
        <dfn aoid="GetBase" id="ao-getbase">GetBase</dfn>(_V_). Returns the base value component of the reference _V_.
      </li>
      <li>
        <dfn aoid="GetReferencedName" id="ao-getreferencedname">GetReferencedName</dfn>(_V_). Returns the referenced name component of the reference _V_.
      </li>
      <li>
        <dfn aoid="IsStrictReference" id="ao-isstrictreference">IsStrictReference</dfn>(_V_). Returns the strict reference flag of the reference _V_.
      </li>
      <li>
        <dfn aoid="HasPrimitiveBase" id="ao-hasprimitivebase">HasPrimitiveBase</dfn>(_V_). Returns *true* if Type(_V_'s base value component) is Boolean, String, Symbol, or Number.
      </li>
      <li>
        <dfn aoid="IsPropertyReference" id="ao-ispropertyreference">IsPropertyReference</dfn>(_V_). Returns *true* if either the base value component of the reference _V_ is an object or HasPrimitiveBase(_V_) is *true*; otherwise returns *false*.
      </li>
      <li>
        <dfn aoid="IsUnresolvableReference" id="ao-isunresolvablereference">IsUnresolvableReference</dfn>(_V_). Returns *true* if the base value component of the reference _V_ is *undefined*; otherwise returns *false*.
      </li>
      <li>
        <dfn aoid="IsSuperReference" id="ao-issuperreference">IsSuperReference</dfn>(_V_). Returns *true* if the reference _V_ has a thisValue component.
      </li>
      <li>
        <ins><dfn aoid="IsAwaitCancelTokenReference" id="ao-isawaitcanceltokenreference">IsAwaitCancelTokenReference</dfn>(_V_). Returns *true* if the base value component of the reference _V_ is an execution context.</ins>
      </li>
    </ul>
    <p>The following abstract operations are used in this specification to operate on references:</p>

    <emu-clause id="sec-getvalue" aoid="GetValue">
      <h1>GetValue (_V_)</h1>
      <emu-alg>
        1. ReturnIfAbrupt(_V_).
        1. If Type(_V_) is not Reference, return _V_.
        1. Let _base_ be GetBase(_V_).
        1. If IsUnresolvableReference(_V_) is *true*, throw a *ReferenceError* exception.
        1. If IsPropertyReference(_V_) is *true*, then
          1. If HasPrimitiveBase(_V_) is *true*, then
            1. Assert: In this case, _base_ will never be *null* or *undefined*.
            1. Let _base_ be ! ToObject(_base_).
          1. Return ? _base_.[[Get]](GetReferencedName(_V_), GetThisValue(_V_)).
        1. <ins>If IsAwaitCancelTokenReference(_V_) is *true*, then</ins>
          1. <ins>Return the value of _base_'s CancelToken component.</ins>
        1. Else _base_ must be an Environment Record,
          1. Return ? _base_.GetBindingValue(GetReferencedName(_V_), IsStrictReference(_V_)) (see <emu-xref href="#sec-environment-records"></emu-xref>).
      </emu-alg>
      <emu-note>
        <p>The object that may be created in step 5.a.ii is not accessible outside of the above abstract operation and the ordinary object [[Get]] internal method. An implementation might choose to avoid the actual creation of the object.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-putvalue" aoid="PutValue">
      <h1>PutValue (_V_, _W_)</h1>
      <emu-alg>
        1. ReturnIfAbrupt(_V_).
        1. ReturnIfAbrupt(_W_).
        1. If Type(_V_) is not Reference, throw a *ReferenceError* exception.
        1. Let _base_ be GetBase(_V_).
        1. If IsUnresolvableReference(_V_) is *true*, then
          1. If IsStrictReference(_V_) is *true*, then
            1. Throw a *ReferenceError* exception.
          1. Let _globalObj_ be GetGlobalObject().
          1. Return ? Set(_globalObj_, GetReferencedName(_V_), _W_, *false*).
        1. Else if IsPropertyReference(_V_) is *true*, then
          1. If HasPrimitiveBase(_V_) is *true*, then
            1. Assert: In this case, _base_ will never be *null* or *undefined*.
            1. Set _base_ to ! ToObject(_base_).
          1. Let _succeeded_ be ? _base_.[[Set]](GetReferencedName(_V_), _W_, GetThisValue(_V_)).
          1. If _succeeded_ is *false* and IsStrictReference(_V_) is *true*, throw a *TypeError* exception.
          1. Return.
        1. <ins>Else if IsAwaitCancelTokenReference(_V_) is *true*, then</ins>
          1. <ins>If _W_ is *undefined*,</ins>
            1. <ins>Set the value of _base_'s CancelToken component to *undefined*.<ins>
          1. <ins>Otherwise,</ins>
            1. <ins>Set the value of _base_'s CancelToken component to *undefined*.<ins>
            1. <ins>If ! IsCancelToken(_W_) is *false*, throw a *TypeError* exception.</ins>
            1. <ins>Set _base_'s CancelToken component to _W_.<ins>
        1. Else _base_ must be an Environment Record,
          1. Return ? _base_.SetMutableBinding(GetReferencedName(_V_), _W_, IsStrictReference(_V_)) (see <emu-xref href="#sec-environment-records"></emu-xref>).
      </emu-alg>
      <emu-note>
        <p>The object that may be created in step 6.a.ii is not accessible outside of the above algorithm and the ordinary object [[Set]] internal method. An implementation might choose to avoid the actual creation of that object.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="async-functions">
    <h1>Async Functions</h1>

    <emu-clause id="abstract-ops-async-function-start">
      <h1>AsyncFunctionStart ( _promiseCapability_, |asyncFunctionBody| )</h1>

      <emu-alg>
        1. Let _runningContext_ be the running execution context.
        1. Let _asyncContext_ be a copy of _runningContext_.
        1. <ins>Set the CancelToken component of _asyncContext_ to *undefined*.</ins>
        1. Set the code evaluation state of _asyncContext_ such that when evaluation is resumed for that execution context the following steps will be performed:
          1. Let _result_ be the result of evaluating _asyncFunctionBody_.
          1. Assert: If we return here, the async function either threw an exception or performed an implicit or explicit return; all awaiting is done.
          1. Remove _asyncContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.
          1. If _result_.[[type]] is ~normal~, then
            1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, « *undefined* »).
          1. Else if _result_.[[type]] is ~return~, then
            1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, « _result_.[[Value]] »).
          1. Else,
            1. Assert: _result_.[[type]] is ~throw~.
            1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « _result_.[[Value]] »).
          1. Return.
        1. Push _asyncContext_ onto the execution context stack; _asyncContext_ is now the running execution context.
        1. Resume the suspended evaluation of _asyncContext_. Let _result_ be the value returned by the resumed computation.
        1. Assert: When we return here, _asyncContext_ has already been removed from the execution context stack and _runningContext_ is the currently running execution context.
        1. Assert: _result_ is a normal completion with a value of *undefined*. The possible sources of completion values are AsyncFunctionAwait or, if the async function doesn't await anything, the step 3.7 above.
        1. Return.
      </emu-alg>
    </emu-clause>

    <emu-clause id="abstract-ops-async-function-await" aoid="AsyncFunctionAwait">
      <h1>AsyncFunctionAwait ( _value_ )</h1>
      <emu-alg>
        1. Let _asyncContext_ be the running execution context.
        1. <ins>Let _cancelToken_ be _asyncContext_'s CancelToken component.</ins>
        1. <ins>If _cancelToken_ is not *undefined*,
          1. <ins>Let _reason_ be ! CancelTokenReason(_cancelToken_).</ins>
          1. <ins>If _reason_ is not *undefined*, return Completion { [[Type]]: ~throw~, [[Value]]: _reason_, [[Target]]: ~empty~ }.</ins>
        1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).
        1. <del>Let _resolveResult_ be</del><ins>Perform</ins> ! Call(_promiseCapability_.[[Resolve]], *undefined*, « _value_ »).
        1. Let _onFulfilled_ be a new built-in function object as defined in <emu-xref title href="#abstract-ops-awaited-fulfilled"></emu-xref>.
        1. Let _onRejected_ be a new built-in function object as defined in <emu-xref title href="#abstract-ops-awaited-rejected"></emu-xref>.
        1. Set _onFulfilled_ and _onRejected_'s [[AsyncContext]] internal slots to _asyncContext_.
        1. <ins>Let _alreadyResumed_ be a new Record { [[Value]]: *false* }.</ins>
        1. <ins>Set _onFulfilled_ and _onReject_'s [[AlreadyResumed]] internal slots to _alreadyResumed_.</ins>
        1. <ins>If _cancelToken_ is not *undefined*,</ins>
          1. <ins>Let _cancelTokenThrowawayCapability_ be ! NewPromiseCapability(%Promise%).</ins>
          1. <ins>Perform ! PerformPromiseThen(_cancelToken_.[[CancelTokenPromise]], _onRejected_, *undefined*, _cancelTokenThrowawayCapability_).</ins>
        1. Let _throwawayCapability_ be NewPromiseCapability(%Promise%). <!-- Kind of lame. This is the equivalent of ignoring the return value -->
        1. Perform ! PerformPromiseThen(_promiseCapability_.[[Promise]], _onFulfilled_, _onRejected_, _throwawayCapability_).
        1. Remove _asyncContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.
        1. Set the code evaluation state of _asyncContext_ such that when evaluation is resumed with a Completion _resumptionValue_ the following steps will be performed:
          1. Return _resumptionValue_.
        1. Return.
      </emu-alg>

      <emu-clause id="abstract-ops-awaited-fulfilled">
        <h1>AsyncFunction Awaited Fulfilled<ins> Functions</ins></h1>

        <p><del>Function _F_ is called with the parameter _value_.</del></p>

        <p><ins>An AsyncFunction awaited fulfilled function is an anonymous built-in function that has [[AsyncContext]] and [[AlreadyResumed]] internal slots.</ins></p>
        <p><ins>When an AsyncFunction awaited fulfilled function _F_ is called with argument _value_, the following steps are taken:</ins></p>

        <emu-alg>
          1. <ins>Let _alreadyResumed_ be _F_.[[AlreadyResumed]].</ins>
          1. <ins>If _alreadyResumed_.[[Value]] is *true*, return *undefined*.</ins>
          1. <ins>Set _alreadyResumed_.[[Value]] to *true*.</ins>
          1. Let _asyncContext_ be <del>the value of _F_'s [[AsyncContext]] internal slot</del><ins>_F_.[[AsyncContext]]</ins>.
          1. Let _prevContext_ be the running execution context.
          1. Suspend _prevContext_.
          1. Push _asyncContext_ onto the execution context stack; _asyncContext_ is now the running execution context.
          1. Resume the suspended evaluation of _asyncContext_ using NormalCompletion(_value_) as the result of the operation that suspended it. Let _result_ be the value returned by the resumed computation.
          1. Assert: When we reach this step, _asyncContext_ has already been removed from the execution context stack and _prevContext_ is the currently running execution context.
          1. Return Completion(_result_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="abstract-ops-awaited-rejected">
        <h1>AsyncFunction Awaited Rejected<ins> Functions</ins></h1>

        <p><del>Function _F_ is called with the parameter _reason_.</del></p>

        <p><ins>An AsyncFunction awaited rejected function is an anonymous built-in function that has [[AsyncContext]] and [[AlreadyResumed]] internal slots.</ins></p>
        <p><ins>When an AsyncFunction awaited rejected function _F_ is called with argument _reason_, the following steps are taken:</ins></p>

        <emu-alg>
          1. <ins>Let _alreadyResumed_ be _F_.[[AlreadyResumed]].</ins>
          1. <ins>If _alreadyResumed_.[[Value]] is *true*, return *undefined*.</ins>
          1. <ins>Set _alreadyResumed_.[[Value]] to *true*.</ins>
          1. Let _asyncContext_ be <del>the value of _F_'s [[AsyncContext]] internal slot</del><ins>_F_.[[AsyncContext]]</ins>.
          1. Let _prevContext_ be the running execution context.
          1. Suspend _prevContext_.
          1. Push _asyncContext_ onto the execution context stack; _asyncContext_ is now the running execution context.
          1. Resume the suspended evaluation of _asyncContext_ using Completion{[[type]]: ~throw~, [[value]]: _reason_, [[target]]: ~empty~} as the result of the operation that suspended it. Let _result_ be the value returned by the resumed computation.
          1. Assert: When we reach this step, _asyncContext_ has already been removed from the execution context stack and _prevContext_ is the currently running execution context.
          1. Return Completion(_result_).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="ArrowFunction">
    <h1>|ArrowFunction|</h1>
    <emu-production name="ArrowFunction" params="Yield, In, Await">
      <emu-rhs><emu-nt params="?Yield, ?Await">ArrowParameters</emu-nt> <emu-gann>no <emu-nt>LineTerminator</emu-nt> here</emu-gann> => <emu-nt params="?In">ConciseBody</emu-nt></emu-rhs>
    </emu-production>

    <emu-clause id="arrow-function-static-semantics-early-errors">
      <h1>Static Semantics: Early Errors</h1>
      <p>
        <emu-prodref name="ArrowFunction" class="inline"></emu-prodref>
      </p>
      <ul>
        <li>It is a Syntax Error if |ArrowParameters| Contains |YieldExpression| is *true*.
        <li>It is a Syntax Error if |ArrowParameters| Contains |AwaitExpression| is *true*.
        <li><ins>It is a Syntax Error if |ArrowParameters| Contains |AwaitCancelToken| is *true*.</ins>
        <li>It is a Syntax Error if any element of the BoundNames of |ArrowParameters| also occurs in the LexicallyDeclaredNames of |ConciseBody|.
      </ul>
    </emu-clause>
  </emu-clause>
</emu-clause>
